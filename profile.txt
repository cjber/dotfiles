Time	Sum	Command
984	9820	> builtin source /usr/share/fish/config.fish
28	28	-> set -g IFS \n\ \t
7	7	-> set -qg __fish_added_user_paths
9	9	-> set -g __fish_added_user_paths
3	9	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
6	6	--> not set -q __fish_initialized
7	7	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
6	139	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
7	7	--> status --is-interactive
8	126	--> if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    ...
6	6	---> not set -q STY
18	18	---> not string match -q -- 'eterm*' $TERM
10	75	---> begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        ...
6	6	----> set -q KONSOLE_PROFILE_NAME
11	11	----> string match -q -- "*:*" $ITERM_SESSION_ID
10	10	----> string match -q -- "st-*" $TERM
23	23	----> test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600
15	15	----> test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit
6	6	---> set -q fish_term24bit
13	13	---> set -g fish_term24bit 1
7	7	-> set -l __extra_completionsdir
7	7	-> set -l __extra_functionsdir
7	7	-> set -l __extra_confdir
7	108	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
14	14	--> test -f $__fish_data_dir/__fish_build_paths.fish
60	87	--> source $__fish_data_dir/__fish_build_paths.fish
13	13	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
7	7	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
7	7	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
7	7	-> set -l xdg_data_dirs
5	21	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
6	6	--> set -q XDG_DATA_DIRS
10	10	--> set xdg_data_dirs $__fish_data_dir
10	10	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
9	9	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
9	9	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
4	30	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
14	14	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
12	12	--> set -a vendor_completionsdirs $__extra_completionsdir
4	26	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
11	11	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
11	11	--> set -a vendor_functionsdirs $__extra_functionsdir
2	15	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
7	7	--> not contains -- $__extra_confdir $vendor_confdirs
6	6	--> set -a vendor_confdirs $__extra_confdir
3	19	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
4	4	--> not set -q fish_function_path
12	12	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
3	19	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
3	3	--> not set -q fish_complete_path
13	13	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
4	4	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
1	14	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
3	13	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
4	4	---> not set -q FISH_UNIT_TESTS_RUNNING
6	6	---> test -d /usr/xpg4/bin
5	5	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
8	8	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
3	3	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
90	337	-> __fish_set_locale
195	198	--> source /usr/share/fish/functions/__fish_set_locale.fish
3	3	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
6	6	--> set -l LOCALE_VARS
7	7	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
6	6	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
6	6	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
13	24	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
2	11	---> if set -q $locale_var
            return 0
        ...
5	5	----> set -q $locale_var
4	4	----> return 0
5	5	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
2	10	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
8	8	--> test $__fish_initialized -lt 2300
2	5	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
3	3	--> status --is-login
10	375	-> __fish_reconstruct_path
14	14	--> set -l local_path $PATH
10	10	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
5	5	--> set -g __fish_added_user_paths
3	319	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
3	3	---> set -q fish_user_paths
44	313	---> for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        ...
25	25	----> string split ":" -- $fish_user_paths[-1..1]
3	72	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
28	59	-----> set -l idx (contains --index -- $x $local_path)
31	31	------> contains --index -- $x $local_path
10	10	-----> set -e local_path[$idx]
7	7	----> set -p local_path $x
4	52	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
25	41	-----> set -l idx (contains --index -- $x $local_path)
16	16	------> contains --index -- $x $local_path
7	7	-----> set -e local_path[$idx]
6	6	----> set -p local_path $x
2	46	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
23	37	-----> set -l idx (contains --index -- $x $local_path)
14	14	------> contains --index -- $x $local_path
7	7	-----> set -e local_path[$idx]
7	7	----> set -p local_path $x
3	48	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
22	38	-----> set -l idx (contains --index -- $x $local_path)
16	16	------> contains --index -- $x $local_path
7	7	-----> set -e local_path[$idx]
6	6	----> set -p local_path $x
17	17	--> set -xg PATH $local_path
3	3	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
10	24	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
4	4	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
3	3	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
4	4	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
3	3	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
2	2	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
5	5	-> set -l sourcelist
104	7543	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
30	58	--> set -l basename (string replace -r '^.*/' '' -- $file)
28	28	---> string replace -r '^.*/' '' -- $file
8	8	--> contains -- $basename $sourcelist
7	7	--> set sourcelist $sourcelist $basename
13	13	--> [ -f $file -a -r $file ]
241	894	--> source $file
4	4	---> status is-interactive
8	8	---> set -l xdg_runtime_dir "$XDG_RUNTIME_DIR"
5	5	---> test -z "$xdg_runtime_dir"
6	6	---> set -g __async_prompt_tmpdir "$xdg_runtime_dir/fish-async-prompt"
547	547	---> mkdir -p $__async_prompt_tmpdir
6	6	---> function __async_prompt_setup_on_startup --on-event fish_prompt
    functions -e (status current-function)

    for func in (__async_prompt_config_functions)
        function $func -V func
            test -e $__async_prompt_tmpdir'/'$fish_pid'_'$func
            and cat $__async_prompt_tmpdir'/'$fish_pid'_'$func
        end
    end
...
3	3	---> function __async_prompt_fire --on-event fish_prompt
    set st $status

    for func in (__async_prompt_config_functions)
        set -l tmpfile $__async_prompt_tmpdir'/'$fish_pid'_'$func

        if functions -q $func'_loading_indicator' && test -e $tmpfile
            read -zl last_prompt <$tmpfile
            eval (string escape -- $func'_loading_indicator' "$last_prompt") >$tmpfile
        end

        __async_prompt_config_inherit_variables | __async_prompt_spawn $st \
            $func' | read -z prompt
            echo -n $prompt >'$tmpfile
    end
...
2	2	---> function __async_prompt_spawn
    set -l envs
    begin
        set st $argv[1]
        while read line
            switch "$line"
                case FISH_VERSION PWD _ history 'fish_*' hostname version
                case status
                    echo status $st
                case SHLVL
                    set envs $envs SHLVL=(math $SHLVL - 1)
                case '*'
                    echo $line (string escape -- $$line)
            end
        end
    end | read -lz vars
    echo $vars | env $envs fish -c '
    function __async_prompt_set_status
        return $argv
    end
    function __async_prompt_signal
        kill -s "'(__async_prompt_config_internal_signal)'" '$fish_pid'
    end
    while read -a line
        test -z "$line"
        and continue

        if test "$line[1]" = status
            set st $line[2]
        else
            eval set "$line"
        end
    end

    not set -q st
    and true
    or __async_prompt_set_status $st
    '$argv[2]'
    __async_prompt_signal
    sleep 0.3
    __async_prompt_signal
    sleep 0.3
    __async_prompt_signal' &
    disown
...
2	2	---> function __async_prompt_config_inherit_variables
    if set -q async_prompt_inherit_variables
        if test "$async_prompt_inherit_variables" = all
            set -ng
        else
            for item in $async_prompt_inherit_variables
                echo $item
            end
        end
    else
        echo status
        echo SHLVL
        echo CMD_DURATION
    end
...
2	2	---> function __async_prompt_config_functions
    set -l funcs (
        if set -q $async_prompt_functions
            string join \n $async_prompt_functions
        else
            echo fish_prompt
            echo fish_right_prompt
        end
    )
    for func in $funcs
        functions -q "$func"
        or continue

        echo $func
    end
...
2	2	---> function __async_prompt_config_internal_signal
    if test -z "$async_prompt_signal_number"
        echo SIGUSR1
    else
        echo "$async_prompt_signal_number"
    end
...
28	66	---> function __async_prompt_repaint_prompt --on-signal (__async_prompt_config_internal_signal)
    commandline -f repaint >/dev/null 2>/dev/null
...
10	38	----> __async_prompt_config_internal_signal
5	28	-----> if test -z "$async_prompt_signal_number"
        echo SIGUSR1
    else
        echo "$async_prompt_signal_number"
    ...
9	9	------> test -z "$async_prompt_signal_number"
14	14	------> echo SIGUSR1
25	39	--> set -l basename (string replace -r '^.*/' '' -- $file)
14	14	---> string replace -r '^.*/' '' -- $file
7	7	--> contains -- $basename $sourcelist
7	7	--> set sourcelist $sourcelist $basename
11	11	--> [ -f $file -a -r $file ]
180	993	--> source $file
5	5	---> set -q FZF_TMUX_HEIGHT
3	3	---> set -q FZF_DEFAULT_OPTS
3	3	---> set -q FZF_LEGACY_KEYBINDINGS
3	3	---> set -q FZF_DISABLE_KEYBINDINGS
3	3	---> set -q FZF_PREVIEW_FILE_CMD
3	3	---> set -q FZF_PREVIEW_DIR_CMD
4	788	---> if test "$FZF_DISABLE_KEYBINDINGS" -ne 1
    if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if test "$fish_key_bindings" = fish_vi_key_bindings
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if test "$fish_key_bindings" = fish_vi_key_bindings
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    end

    if not bind --user \t >/dev/null 2>/dev/null
        if set -q FZF_COMPLETE
            bind \t '__fzf_complete'
            if test "$fish_key_bindings" = fish_vi_key_bindings
                bind -M insert \t '__fzf_complete'
            end
        end
    end
...
7	7	----> test "$FZF_DISABLE_KEYBINDINGS" -ne 1
4	105	----> if test "$FZF_LEGACY_KEYBINDINGS" -eq 1
        bind \ct '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \cg '__fzf_open'
        bind \co '__fzf_open --editor'

        if test "$fish_key_bindings" = fish_vi_key_bindings
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        end
    else
        bind \co '__fzf_find_file'
        bind \cr '__fzf_reverse_isearch'
        bind \ec '__fzf_cd'
        bind \eC '__fzf_cd --hidden'
        bind \eO '__fzf_open'
        bind \eo '__fzf_open --editor'

        if test "$fish_key_bindings" = fish_vi_key_bindings
            bind -M insert \co '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \eO '__fzf_open'
            bind -M insert \eo '__fzf_open --editor'
        end
    ...
5	5	-----> test "$FZF_LEGACY_KEYBINDINGS" -eq 1
16	16	-----> bind \ct '__fzf_find_file'
6	6	-----> bind \cr '__fzf_reverse_isearch'
6	6	-----> bind \ec '__fzf_cd'
6	6	-----> bind \eC '__fzf_cd --hidden'
6	6	-----> bind \cg '__fzf_open'
5	5	-----> bind \co '__fzf_open --editor'
8	51	-----> if test "$fish_key_bindings" = fish_vi_key_bindings
            bind -M insert \ct '__fzf_find_file'
            bind -M insert \cr '__fzf_reverse_isearch'
            bind -M insert \ec '__fzf_cd'
            bind -M insert \eC '__fzf_cd --hidden'
            bind -M insert \cg '__fzf_open'
            bind -M insert \co '__fzf_open --editor'
        ...
7	7	------> test "$fish_key_bindings" = fish_vi_key_bindings
8	8	------> bind -M insert \ct '__fzf_find_file'
7	7	------> bind -M insert \cr '__fzf_reverse_isearch'
6	6	------> bind -M insert \ec '__fzf_cd'
5	5	------> bind -M insert \eC '__fzf_cd --hidden'
5	5	------> bind -M insert \cg '__fzf_open'
5	5	------> bind -M insert \co '__fzf_open --editor'
7	672	----> if not bind --user \t >/dev/null 2>/dev/null
        if set -q FZF_COMPLETE
            bind \t '__fzf_complete'
            if test "$fish_key_bindings" = fish_vi_key_bindings
                bind -M insert \t '__fzf_complete'
            end
        end
    ...
655	655	-----> not bind --user \t >/dev/null 2>/dev/null
2	10	-----> if set -q FZF_COMPLETE
            bind \t '__fzf_complete'
            if test "$fish_key_bindings" = fish_vi_key_bindings
                bind -M insert \t '__fzf_complete'
            end
        ...
8	8	------> set -q FZF_COMPLETE
5	5	---> function _fzf_uninstall -e fzf_uninstall
    bind --user \
        | string replace --filter --regex -- "bind (.+)( '?__fzf.*)" 'bind -e $1' \
        | source

    set --names \
        | string replace --filter --regex '(^FZF)' 'set --erase $1' \
        | source

    functions --erase _fzf_uninstall
...
2695	2713	--> set -l basename (string replace -r '^.*/' '' -- $file)
18	18	---> string replace -r '^.*/' '' -- $file
21	21	--> contains -- $basename $sourcelist
16	16	--> set sourcelist $sourcelist $basename
29	29	--> [ -f $file -a -r $file ]
258	1366	--> source $file
11	11	---> set -l _pisces_bind_mode default
11	18	---> switch $fish_key_bindings
    case 'fish_vi_key_bindings' 'fish_hybrid_key_bindings'
        set _pisces_bind_mode insert
...
7	7	----> set _pisces_bind_mode insert
5	5	---> set -q pisces_pairs
21	1047	---> for pair in $pisces_pairs
    _pisces_bind_pair $_pisces_bind_mode (string split -- ',' $pair)
...
92	366	----> _pisces_bind_pair $_pisces_bind_mode (string split -- ',' $pair)
94	103	-----> source /home/cjber/.config/fish/functions/_pisces_bind_pair.fish
9	9	------> function _pisces_bind_pair -a mode left right -d "Creates bindings for the given pair: autoclose and skip closing symbol"

    test -n $mode
    or set mode default

    set l $left
    set r $right

    set left  (string escape -n -- $left)
    set right (string escape -n -- $right)

    if [ $left = $right ]

        bind -M $mode $r "_pisces_insert_identical $right"
    else

        bind -M $mode $l "_pisces_insert_left $left $right"
        bind -M $mode $r "_pisces_insert_right $right"
    end
...
15	15	-----> string split -- ',' $pair
9	9	-----> test -n $mode
10	10	-----> set l $left
7	7	-----> set r $right
34	46	-----> set left  (string escape -n -- $left)
12	12	------> string escape -n -- $left
31	42	-----> set right (string escape -n -- $right)
11	11	------> string escape -n -- $right
6	42	-----> if [ $left = $right ]

        bind -M $mode $r "_pisces_insert_identical $right"
    else

        bind -M $mode $l "_pisces_insert_left $left $right"
        bind -M $mode $r "_pisces_insert_right $right"
    ...
9	9	------> [ $left = $right ]
15	15	------> bind -M $mode $l "_pisces_insert_left $left $right"
12	12	------> bind -M $mode $r "_pisces_insert_right $right"
52	172	----> _pisces_bind_pair $_pisces_bind_mode (string split -- ',' $pair)
10	10	-----> string split -- ',' $pair
5	5	-----> test -n $mode
6	6	-----> set l $left
4	4	-----> set r $right
27	36	-----> set left  (string escape -n -- $left)
9	9	------> string escape -n -- $left
24	33	-----> set right (string escape -n -- $right)
9	9	------> string escape -n -- $right
5	26	-----> if [ $left = $right ]

        bind -M $mode $r "_pisces_insert_identical $right"
    else

        bind -M $mode $l "_pisces_insert_left $left $right"
        bind -M $mode $r "_pisces_insert_right $right"
    ...
5	5	------> [ $left = $right ]
9	9	------> bind -M $mode $l "_pisces_insert_left $left $right"
7	7	------> bind -M $mode $r "_pisces_insert_right $right"
36	146	----> _pisces_bind_pair $_pisces_bind_mode (string split -- ',' $pair)
8	8	-----> string split -- ',' $pair
5	5	-----> test -n $mode
5	5	-----> set l $left
4	4	-----> set r $right
25	32	-----> set left  (string escape -n -- $left)
7	7	------> string escape -n -- $left
21	28	-----> set right (string escape -n -- $right)
7	7	------> string escape -n -- $right
4	28	-----> if [ $left = $right ]

        bind -M $mode $r "_pisces_insert_identical $right"
    else

        bind -M $mode $l "_pisces_insert_left $left $right"
        bind -M $mode $r "_pisces_insert_right $right"
    ...
6	6	------> [ $left = $right ]
10	10	------> bind -M $mode $l "_pisces_insert_left $left $right"
8	8	------> bind -M $mode $r "_pisces_insert_right $right"
32	126	----> _pisces_bind_pair $_pisces_bind_mode (string split -- ',' $pair)
8	8	-----> string split -- ',' $pair
5	5	-----> test -n $mode
6	6	-----> set l $left
5	5	-----> set r $right
19	26	-----> set left  (string escape -n -- $left)
7	7	------> string escape -n -- $left
19	27	-----> set right (string escape -n -- $right)
8	8	------> string escape -n -- $right
2	17	-----> if [ $left = $right ]

        bind -M $mode $r "_pisces_insert_identical $right"
    else

        bind -M $mode $l "_pisces_insert_left $left $right"
        bind -M $mode $r "_pisces_insert_right $right"
    ...
6	6	------> [ $left = $right ]
9	9	------> bind -M $mode $r "_pisces_insert_identical $right"
33	216	----> _pisces_bind_pair $_pisces_bind_mode (string split -- ',' $pair)
7	7	-----> string split -- ',' $pair
6	6	-----> test -n $mode
5	5	-----> set l $left
5	5	-----> set r $right
21	30	-----> set left  (string escape -n -- $left)
9	9	------> string escape -n -- $left
32	108	-----> set right (string escape -n -- $right)
76	76	------> string escape -n -- $right
3	22	-----> if [ $left = $right ]

        bind -M $mode $r "_pisces_insert_identical $right"
    else

        bind -M $mode $l "_pisces_insert_left $left $right"
        bind -M $mode $r "_pisces_insert_right $right"
    ...
8	8	------> [ $left = $right ]
11	11	------> bind -M $mode $r "_pisces_insert_identical $right"
8	8	---> bind -M $_pisces_bind_mode \b _pisces_backspace
7	7	---> bind -M $_pisces_bind_mode \177 _pisces_backspace
7	7	---> bind -M $_pisces_bind_mode \t _pisces_complete
5	5	---> function _pisces_uninstall --on-event pisces_uninstall
    # NOTE: won't work as expected if user has changed the mode after installation
    set -l _pisces_bind_mode default
    switch $fish_key_bindings
        case 'fish_vi_key_bindings' 'fish_hybrid_key_bindings'
            set _pisces_bind_mode insert
    end

    for pair in $pisces_pairs
        for c in (string split -- ',' $pair)
            bind -e -M $_pisces_bind_mode $c
        end
    end

    bind -M $_pisces_bind_mode \b   backward-delete-char
    bind -M $_pisces_bind_mode \177 backward-delete-char
    bind -M $_pisces_bind_mode \t   complete

    set -e pisces_pairs
...
31	47	--> set -l basename (string replace -r '^.*/' '' -- $file)
16	16	---> string replace -r '^.*/' '' -- $file
9	9	--> contains -- $basename $sourcelist
8	8	--> set sourcelist $sourcelist $basename
13	13	--> [ -f $file -a -r $file ]
55	507	--> source $file
6	6	---> bind . _puffer_fish_expand_dots
6	6	---> bind . -M insert _puffer_fish_expand_dots
5	5	---> bind ! _puffer_fish_expand_bang
5	5	---> bind ! -M insert _puffer_fish_expand_bang
45	421	---> set -l uninstall_event (basename (status -f) .fish)_uninstall
368	376	----> basename (status -f) .fish
8	8	-----> status -f
9	9	---> function $uninstall_event --on-event $uninstall_event
    bind -e .
    bind -e !
...
76	98	--> set -l basename (string replace -r '^.*/' '' -- $file)
22	22	---> string replace -r '^.*/' '' -- $file
9	9	--> contains -- $basename $sourcelist
8	8	--> set sourcelist $sourcelist $basename
12	12	--> [ -f $file -a -r $file ]
134	422	--> source $file
3	10	---> if test -z "$Z_DATA"
  if test -z "$XDG_DATA_HOME"
    set -U Z_DATA_DIR "$HOME/.local/share/z"
  else 
    set -U Z_DATA_DIR "$XDG_DATA_HOME/z"
  end
  set -U Z_DATA "$Z_DATA_DIR/data"
...
7	7	----> test -z "$Z_DATA"
2	11	---> if test ! -e "$Z_DATA"
  if test ! -e "$Z_DATA_DIR"
    mkdir -p -m 700 "$Z_DATA_DIR"  
  end
  touch "$Z_DATA"
...
9	9	----> test ! -e "$Z_DATA"
2	7	---> if test -z "$Z_CMD"
  set -U Z_CMD "z"
...
5	5	----> test -z "$Z_CMD"
11	11	---> set -U ZO_CMD "$Z_CMD"o
4	15	---> if test ! -z $Z_CMD
  function $Z_CMD -d "jump around"
    __z $argv
  end
...
5	5	----> test ! -z $Z_CMD
6	6	----> function $Z_CMD -d "jump around"
    __z $argv
  ...
3	11	---> if test ! -z $ZO_CMD
  function $ZO_CMD -d "open target dir"
    __z -d $argv
  end
...
5	5	----> test ! -z $ZO_CMD
3	3	----> function $ZO_CMD -d "open target dir"
    __z -d $argv
  ...
3	14	---> if not set -q Z_EXCLUDE
  set -U Z_EXCLUDE "^$HOME\$"
else if contains $HOME $Z_EXCLUDE
  # Workaround: migrate old default values to a regex (see #90).
  set Z_EXCLUDE (string replace -r -- "^$HOME\$" '^'$HOME'$$' $Z_EXCLUDE)
...
4	4	----> not set -q Z_EXCLUDE
7	7	----> contains $HOME $Z_EXCLUDE
41	201	---> __z_complete
68	72	----> source /home/cjber/.config/fish/functions/__z_complete.fish
4	4	-----> function __z_complete -d "add completions"
  function __z_marks
      printf "%s\n" (string replace -r '\|.*' '' < $Z_DATA)
  end

  complete -c $Z_CMD -a "(__z_marks)" -f
  complete -c $ZO_CMD -a "(__z_marks)" -f

  complete -c $Z_CMD -s c -l clean  -d "Cleans out $Z_DATA"
  complete -c $Z_CMD -s e -l echo   -d "Prints best match, no cd"
  complete -c $Z_CMD -s l -l list   -d "List matches, no cd"
  complete -c $Z_CMD -s p -l purge  -d "Purges $Z_DATA"
  complete -c $Z_CMD -s r -l rank   -d "Searches by rank, cd"
  complete -c $Z_CMD -s t -l recent -d "Searches by recency, cd"
  complete -c $Z_CMD -s h -l help   -d "Print help"
...
2	2	----> function __z_marks
      printf "%s\n" (string replace -r '\|.*' '' < $Z_DATA)
  ...
25	25	----> complete -c $Z_CMD -a "(__z_marks)" -f
9	9	----> complete -c $ZO_CMD -a "(__z_marks)" -f
9	9	----> complete -c $Z_CMD -s c -l clean  -d "Cleans out $Z_DATA"
7	7	----> complete -c $Z_CMD -s e -l echo   -d "Prints best match, no cd"
7	7	----> complete -c $Z_CMD -s l -l list   -d "List matches, no cd"
8	8	----> complete -c $Z_CMD -s p -l purge  -d "Purges $Z_DATA"
7	7	----> complete -c $Z_CMD -s r -l rank   -d "Searches by rank, cd"
7	7	----> complete -c $Z_CMD -s t -l recent -d "Searches by recency, cd"
7	7	----> complete -c $Z_CMD -s h -l help   -d "Print help"
4	4	---> function __z_on_variable_pwd --on-variable PWD
  __z_add
...
4	4	---> function __z_uninstall --on-event z_uninstall
  functions -e __z_on_variable_pwd
  functions -e $Z_CMD
  functions -e $ZO_CMD

  if test ! -z "$Z_DATA"
      printf "To completely erase z's data, remove:\n" > /dev/stderr
      printf "%s\n" "$Z_DATA" > /dev/stderr
  end

  set -e Z_CMD
  set -e ZO_CMD
  set -e Z_DATA
  set -e Z_EXCLUDE
...
27	41	--> set -l basename (string replace -r '^.*/' '' -- $file)
14	14	---> string replace -r '^.*/' '' -- $file
10	10	--> contains -- $basename $sourcelist
9	9	--> set sourcelist $sourcelist $basename
13	13	--> [ -f $file -a -r $file ]
45	51	--> source $file
2	6	---> if status --is-login
    for perldir in /usr/bin/site_perl /usr/bin/vendor_perl /usr/bin/core_perl
        if test -d $perldir; and not contains $perldir $PATH
            set PATH $PATH $perldir
        end
    end
...
4	4	----> status --is-login
19	19	> builtin source /etc/fish/config.fish
179	103575	> builtin source /home/cjber/.config/fish/config.fish
3	18	-> if status --is-interactive
  if test -z "$DISPLAY" -a $XDG_VTNR = 1
    exec startx -- -keeptty
  end
...
4	4	--> status --is-interactive
2	11	--> if test -z "$DISPLAY" -a $XDG_VTNR = 1
    exec startx -- -keeptty
  ...
9	9	---> test -z "$DISPLAY" -a $XDG_VTNR = 1
142	6363	-> fish_vi_key_bindings
791	796	--> source /usr/share/fish/functions/fish_vi_key_bindings.fish
5	5	---> function fish_vi_key_bindings --description 'vi-like key bindings for fish'
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    # Erase all bindings if not explicitly requested otherwise to
    # allow for hybrid bindings.
    # This needs to be checked here because if we are called again
    # via the variable handler the argument will be gone.
    set -l rebind true
    if test "$argv[1]" = "--no-erase"
        set rebind false
        set -e argv[1]
    else
        bind --erase --all --preset # clear earlier bindings, if any
    end

    # Allow just calling this function to correctly set the bindings.
    # Because it's a rather discoverable name, users will execute it
    # and without this would then have subtly broken bindings.
    if test "$fish_key_bindings" != "fish_vi_key_bindings"
        and test "$rebind" = "true"
        # Allow the user to set the variable universally.
        set -q fish_key_bindings
        or set -g fish_key_bindings
        # This triggers the handler, which calls us again and ensures the user_key_bindings
        # are executed.
        set fish_key_bindings fish_vi_key_bindings
        return
    end

    set -l init_mode insert
    # These are only the special vi-style keys
    # not end/home, we share those.
    set -l eol_keys \$ g\$
    set -l bol_keys \^ 0 g\^

    if contains -- $argv[1] insert default visual
        set init_mode $argv[1]
    else if set -q argv[1]
        # We should still go on so the bindings still get set.
        echo "Unknown argument $argv" >&2
    end

    # Inherit shared key bindings.
    # Do this first so vi-bindings win over default.
    for mode in insert default visual
        __fish_shared_key_bindings -s -M $mode
    end

    bind -s --preset -M insert \r execute
    bind -s --preset -M insert \n execute

    bind -s --preset -M insert "" self-insert
    # Space expands abbrs _and_ inserts itself.
    bind -s --preset -M insert " " self-insert expand-abbr

    # Add a way to switch from insert to normal (command) mode.
    # Note if we are paging, we want to stay in insert mode
    # See #2871
    bind -s --preset -M insert \e "if commandline -P; commandline -f cancel; else; set fish_bind_mode default; commandline -f backward-char repaint-mode; end"

    # Default (command) mode
    bind -s --preset :q exit
    bind -s --preset -m insert \cc __fish_cancel_commandline
    bind -s --preset -M default h backward-char
    bind -s --preset -M default l forward-char
    bind -s --preset -m insert \n execute
    bind -s --preset -m insert \r execute
    bind -s --preset -m insert i repaint-mode
    bind -s --preset -m insert I beginning-of-line repaint-mode
    bind -s --preset -m insert a forward-char repaint-mode
    bind -s --preset -m insert A end-of-line repaint-mode
    bind -s --preset -m visual v begin-selection repaint-mode

    #bind -s --preset -m insert o "commandline -a \n" down-line repaint-mode
    #bind -s --preset -m insert O beginning-of-line "commandline -i \n" up-line repaint-mode # doesn't work

    bind -s --preset gg beginning-of-buffer
    bind -s --preset G end-of-buffer

    for key in $eol_keys
        bind -s --preset $key end-of-line
    end
    for key in $bol_keys
        bind -s --preset $key beginning-of-line
    end

    bind -s --preset u history-search-backward
    bind -s --preset \cr history-search-forward

    bind -s --preset [ history-token-search-backward
    bind -s --preset ] history-token-search-forward

    bind -s --preset k up-or-search
    bind -s --preset j down-or-search
    bind -s --preset b backward-word
    bind -s --preset B backward-bigword
    bind -s --preset ge backward-word
    bind -s --preset gE backward-bigword
    bind -s --preset w forward-word forward-char
    bind -s --preset W forward-bigword forward-char
    bind -s --preset e forward-char forward-word backward-char
    bind -s --preset E forward-bigword backward-char

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    # Vi/Vim doesn't support these keys in insert mode but that seems silly so we do so anyway.
    bind -s --preset -M insert -k home beginning-of-line 2>/dev/null
    bind -s --preset -M default -k home beginning-of-line 2>/dev/null
    bind -s --preset -M insert -k end end-of-line 2>/dev/null
    bind -s --preset -M default -k end end-of-line 2>/dev/null

    # Vi moves the cursor back if, after deleting, it is at EOL.
    # To emulate that, move forward, then backward, which will be a NOP
    # if there is something to move forward to.
    bind -s --preset -M default x delete-char forward-char backward-char
    bind -s --preset -M default X backward-delete-char
    bind -s --preset -M insert -k dc delete-char forward-char backward-char
    bind -s --preset -M default -k dc delete-char forward-char backward-char

    # Backspace deletes a char in insert mode, but not in normal/default mode.
    bind -s --preset -M insert -k backspace backward-delete-char
    bind -s --preset -M default -k backspace backward-char
    bind -s --preset -M insert \ch backward-delete-char
    bind -s --preset -M default \ch backward-char
    bind -s --preset -M insert \x7f backward-delete-char
    bind -s --preset -M default \x7f backward-char
    bind -s --preset -M insert \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete
    bind -s --preset -M default \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind -s --preset dd kill-whole-line
    bind -s --preset D kill-line
    bind -s --preset d\$ kill-line
    bind -s --preset d\^ backward-kill-line
    bind -s --preset d0 backward-kill-line
    bind -s --preset dw kill-word
    bind -s --preset dW kill-bigword
    bind -s --preset diw forward-char forward-char backward-word kill-word
    bind -s --preset diW forward-char forward-char backward-bigword kill-bigword
    bind -s --preset daw forward-char forward-char backward-word kill-word
    bind -s --preset daW forward-char forward-char backward-bigword kill-bigword
    bind -s --preset de kill-word
    bind -s --preset dE kill-bigword
    bind -s --preset db backward-kill-word
    bind -s --preset dB backward-kill-bigword
    bind -s --preset dge backward-kill-word
    bind -s --preset dgE backward-kill-bigword
    bind -s --preset df begin-selection forward-jump kill-selection end-selection
    bind -s --preset dt begin-selection forward-jump backward-char kill-selection end-selection
    bind -s --preset dF begin-selection backward-jump kill-selection end-selection
    bind -s --preset dT begin-selection backward-jump forward-char kill-selection end-selection

    bind -s --preset -m insert s delete-char repaint-mode
    bind -s --preset -m insert S kill-whole-line repaint-mode
    bind -s --preset -m insert cc kill-whole-line repaint-mode
    bind -s --preset -m insert C kill-line repaint-mode
    bind -s --preset -m insert c\$ kill-line repaint-mode
    bind -s --preset -m insert c\^ backward-kill-line repaint-mode
    bind -s --preset -m insert cw kill-word repaint-mode
    bind -s --preset -m insert cW kill-bigword repaint-mode
    bind -s --preset -m insert ciw forward-char forward-char backward-word kill-word repaint-mode
    bind -s --preset -m insert ciW forward-char forward-char backward-bigword kill-bigword repaint-mode
    bind -s --preset -m insert caw forward-char forward-char backward-word kill-word repaint-mode
    bind -s --preset -m insert caW forward-char forward-char backward-bigword kill-bigword repaint-mode
    bind -s --preset -m insert ce kill-word repaint-mode
    bind -s --preset -m insert cE kill-bigword repaint-mode
    bind -s --preset -m insert cb backward-kill-word repaint-mode
    bind -s --preset -m insert cB backward-kill-bigword repaint-mode
    bind -s --preset -m insert cge backward-kill-word repaint-mode
    bind -s --preset -m insert cgE backward-kill-bigword repaint-mode

    bind -s --preset '~' capitalize-word
    bind -s --preset gu downcase-word
    bind -s --preset gU upcase-word

    bind -s --preset J end-of-line delete-char
    bind -s --preset K 'man (commandline -t) 2>/dev/null; or echo -n \a'

    bind -s --preset yy kill-whole-line yank
    bind -s --preset Y kill-whole-line yank
    bind -s --preset y\$ kill-line yank
    bind -s --preset y\^ backward-kill-line yank
    bind -s --preset yw kill-word yank
    bind -s --preset yW kill-bigword yank
    bind -s --preset yiw forward-char forward-char backward-word kill-word yank
    bind -s --preset yiW forward-char forward-char backward-bigword kill-bigword yank
    bind -s --preset yaw forward-char forward-char backward-word kill-word yank
    bind -s --preset yaW forward-char forward-char backward-bigword kill-bigword yank
    bind -s --preset ye kill-word yank
    bind -s --preset yE kill-bigword yank
    bind -s --preset yb backward-kill-word yank
    bind -s --preset yB backward-kill-bigword yank
    bind -s --preset yge backward-kill-word yank
    bind -s --preset ygE backward-kill-bigword yank

    bind -s --preset f forward-jump
    bind -s --preset F backward-jump
    bind -s --preset t forward-jump-till
    bind -s --preset T backward-jump-till
    bind -s --preset ';' repeat-jump
    bind -s --preset , repeat-jump-reverse

    # in emacs yank means paste
    bind -s --preset p yank
    bind -s --preset P backward-char yank
    bind -s --preset gp yank-pop

    bind -s --preset '"*p' "commandline -i ( xsel -p; echo )[1]"
    bind -s --preset '"*P' backward-char "commandline -i ( xsel -p; echo )[1]"

    #
    # Lowercase r, enters replace_one mode
    #
    bind -s --preset -m replace_one r repaint-mode
    bind -s --preset -M replace_one -m default '' delete-char self-insert backward-char repaint-mode
    bind -s --preset -M replace_one -m default \r 'commandline -f delete-char; commandline -i \n; commandline -f backward-char; commandline -f repaint-mode'
    bind -s --preset -M replace_one -m default \e cancel repaint-mode

    #
    # Uppercase R, enters replace mode
    #
    bind -s --preset -m replace R repaint-mode
    bind -s --preset -M replace '' delete-char self-insert
    bind -s --preset -M replace -m insert \r execute repaint-mode
    bind -s --preset -M replace -m default \e cancel repaint-mode
    # in vim (and maybe in vi), <BS> deletes the changes
    # but this binding just move cursor backward, not delete the changes
    bind -s --preset -M replace -k backspace backward-char

    #
    # visual mode
    #
    bind -s --preset -M visual h backward-char
    bind -s --preset -M visual l forward-char

    bind -s --preset -M visual k up-line
    bind -s --preset -M visual j down-line

    bind -s --preset -M visual b backward-word
    bind -s --preset -M visual B backward-bigword
    bind -s --preset -M visual ge backward-word
    bind -s --preset -M visual gE backward-bigword
    bind -s --preset -M visual w forward-word
    bind -s --preset -M visual W forward-bigword
    bind -s --preset -M visual e forward-word
    bind -s --preset -M visual E forward-bigword
    bind -s --preset -M visual o swap-selection-start-stop repaint-mode

    bind -s --preset -M visual f forward-jump
    bind -s --preset -M visual t forward-jump-till
    bind -s --preset -M visual F backward-jump
    bind -s --preset -M visual T backward-jump-till

    for key in $eol_keys
        bind -s --preset -M visual $key end-of-line
    end
    for key in $bol_keys
        bind -s --preset -M visual $key beginning-of-line
    end

    bind -s --preset -M visual -m insert c kill-selection end-selection repaint-mode
    bind -s --preset -M visual -m default d kill-selection end-selection repaint-mode
    bind -s --preset -M visual -m default x kill-selection end-selection repaint-mode
    bind -s --preset -M visual -m default X kill-whole-line end-selection repaint-mode
    bind -s --preset -M visual -m default y kill-selection yank end-selection repaint-mode
    bind -s --preset -M visual -m default '"*y' "commandline -s | xsel -p; commandline -f end-selection repaint-mode"

    bind -s --preset -M visual -m default \cc end-selection repaint-mode
    bind -s --preset -M visual -m default \e end-selection repaint-mode

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also, remove
    # the commenting chars so the command can be further edited then executed.
    bind -s --preset -M default \# __fish_toggle_comment_commandline
    bind -s --preset -M visual \# __fish_toggle_comment_commandline
    bind -s --preset -M replace \# __fish_toggle_comment_commandline

    # Set the cursor shape
    # After executing once, this will have defined functions listening for the variable.
    # Therefore it needs to be before setting fish_bind_mode.
    fish_vi_cursor

    set fish_bind_mode $init_mode

...
3	14	--> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
7	7	---> contains -- -h $argv
4	4	---> contains -- --help $argv
6	6	--> set -l rebind true
4	17	--> if test "$argv[1]" = "--no-erase"
        set rebind false
        set -e argv[1]
    else
        bind --erase --all --preset # clear earlier bindings, if any
    ...
7	7	---> test "$argv[1]" = "--no-erase"
6	6	---> bind --erase --all --preset
1	8	--> if test "$fish_key_bindings" != "fish_vi_key_bindings"
        and test "$rebind" = "true"
        # Allow the user to set the variable universally.
        set -q fish_key_bindings
        or set -g fish_key_bindings
        # This triggers the handler, which calls us again and ensures the user_key_bindings
        # are executed.
        set fish_key_bindings fish_vi_key_bindings
        return
    ...
7	7	---> test "$fish_key_bindings" != "fish_vi_key_bindings"
5	5	--> set -l init_mode insert
6	6	--> set -l eol_keys \$ g\$
6	6	--> set -l bol_keys \^ 0 g\^
3	13	--> if contains -- $argv[1] insert default visual
        set init_mode $argv[1]
    else if set -q argv[1]
        # We should still go on so the bindings still get set.
        echo "Unknown argument $argv" >&2
    ...
6	6	---> contains -- $argv[1] insert default visual
4	4	---> set -q argv[1]
11	3413	--> for mode in insert default visual
        __fish_shared_key_bindings -s -M $mode
    ...
103	1351	---> __fish_shared_key_bindings -s -M $mode
414	426	----> source /usr/share/fish/functions/__fish_shared_key_bindings.fish
5	5	-----> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    bind --preset $argv -k sright forward-bigword
    bind --preset $argv -k sleft backward-bigword

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew __fish_whatis_current_token
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Prepend 'sudo ' to the current commandline
    bind --preset $argv \es __fish_prepend_sudo

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Tmux' focus events.
    # Exclude paste mode because that should get _everything_ literally.
    for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    end

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1
    # (though it only supports it since then, it seems to be the last term to gain support).
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste.

    # Bind the starting sequence in every bind mode, even user-defined ones.
    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    bind --preset -M paste \r "commandline -i \n"

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
    # Only insert spaces if we're either quoted or not at the beginning of the commandline
    # - this strips leading spaces if they would trigger histignore.
    bind --preset -M paste " " self-insert-notfirst
...
4	4	-----> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
2	2	-----> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
1	1	-----> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
2	18	----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
9	9	-----> contains -- -h $argv
7	7	-----> contains -- --help $argv
10	10	----> bind --preset $argv \cy yank
8	8	----> bind --preset $argv \ey yank-pop
9	9	----> bind --preset $argv -k right forward-char
7	7	----> bind --preset $argv -k left backward-char
7	7	----> bind --preset $argv \e\[C forward-char
7	7	----> bind --preset $argv \e\[D backward-char
7	7	----> bind --preset $argv \eOC forward-char
7	7	----> bind --preset $argv \eOD backward-char
7	7	----> bind --preset $argv -k ppage beginning-of-history
7	7	----> bind --preset $argv -k npage end-of-history
6	6	----> bind --preset $argv \cx fish_clipboard_copy
7	7	----> bind --preset $argv \cv fish_clipboard_paste
7	7	----> bind --preset $argv \e cancel
6	6	----> bind --preset $argv \t complete
6	6	----> bind --preset $argv \cs pager-toggle-search
7	7	----> bind --preset $argv --key btab complete-and-search
7	7	----> bind --preset $argv \e\n "commandline -i \n"
7	7	----> bind --preset $argv \e\r "commandline -i \n"
7	7	----> bind --preset $argv -k down down-or-search
8	8	----> bind --preset $argv -k up up-or-search
6	6	----> bind --preset $argv \e\[A up-or-search
7	7	----> bind --preset $argv \e\[B down-or-search
6	6	----> bind --preset $argv \eOA up-or-search
7	7	----> bind --preset $argv \eOB down-or-search
8	8	----> bind --preset $argv -k sright forward-bigword
7	7	----> bind --preset $argv -k sleft backward-bigword
7	7	----> bind --preset $argv \e\eOC nextd-or-forward-word
7	7	----> bind --preset $argv \e\eOD prevd-or-backward-word
7	7	----> bind --preset $argv \e\e\[C nextd-or-forward-word
7	7	----> bind --preset $argv \e\e\[D prevd-or-backward-word
7	7	----> bind --preset $argv \eO3C nextd-or-forward-word
7	7	----> bind --preset $argv \eO3D prevd-or-backward-word
7	7	----> bind --preset $argv \e\[3C nextd-or-forward-word
7	7	----> bind --preset $argv \e\[3D prevd-or-backward-word
8	8	----> bind --preset $argv \e\[1\;3C nextd-or-forward-word
7	7	----> bind --preset $argv \e\[1\;3D prevd-or-backward-word
7	7	----> bind --preset $argv \e\[1\;9C nextd-or-forward-word
7	7	----> bind --preset $argv \e\[1\;9D prevd-or-backward-word
7	7	----> bind --preset $argv \e\eOA history-token-search-backward
7	7	----> bind --preset $argv \e\eOB history-token-search-forward
7	7	----> bind --preset $argv \e\e\[A history-token-search-backward
7	7	----> bind --preset $argv \e\e\[B history-token-search-forward
7	7	----> bind --preset $argv \eO3A history-token-search-backward
7	7	----> bind --preset $argv \eO3B history-token-search-forward
7	7	----> bind --preset $argv \e\[3A history-token-search-backward
7	7	----> bind --preset $argv \e\[3B history-token-search-forward
7	7	----> bind --preset $argv \e\[1\;3A history-token-search-backward
7	7	----> bind --preset $argv \e\[1\;3B history-token-search-forward
7	7	----> bind --preset $argv \e\[1\;9A history-token-search-backward
7	7	----> bind --preset $argv \e\[1\;9B history-token-search-forward
7	7	----> bind --preset $argv \e. history-token-search-backward
7	7	----> bind --preset $argv \el __fish_list_current_token
7	7	----> bind --preset $argv \ew __fish_whatis_current_token
8	8	----> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
7	7	----> bind --preset $argv \cc __fish_cancel_commandline
6	6	----> bind --preset $argv \cu backward-kill-line
7	7	----> bind --preset $argv \cw backward-kill-path-component
7	7	----> bind --preset $argv \e\[F end-of-line
7	7	----> bind --preset $argv \e\[H beginning-of-line
8	8	----> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
7	7	----> bind --preset $argv \cd delete-or-exit
7	7	----> bind --preset $argv \es __fish_prepend_sudo
8	8	----> bind --preset $argv -k f1 __fish_man_page
7	7	----> bind --preset $argv \eh __fish_man_page
7	7	----> bind --preset $argv \ep '__fish_paginate'
7	7	----> bind --preset $argv \e\# __fish_toggle_comment_commandline
7	7	----> bind --preset $argv \ee edit_command_buffer
7	7	----> bind --preset $argv \ev edit_command_buffer
42	159	----> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
68	68	-----> bind --list-modes | string match -v paste
15	15	-----> bind --preset -M $mode \e\[I 'emit fish_focus_in'
7	7	-----> bind --preset -M $mode \e\[O false
7	7	-----> bind --preset -M $mode \e\[\?1004h false
7	7	-----> bind --preset -M $mode \e\[I 'emit fish_focus_in'
6	6	-----> bind --preset -M $mode \e\[O false
7	7	-----> bind --preset -M $mode \e\[\?1004h false
31	125	----> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
75	75	-----> bind --list-modes | string match -v paste
11	11	-----> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
8	8	-----> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
7	7	----> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
6	6	----> bind --preset -M paste "" self-insert
6	6	----> bind --preset -M paste \r "commandline -i \n"
7	7	----> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
6	6	----> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
6	6	----> bind --preset -M paste " " self-insert-notfirst
71	959	---> __fish_shared_key_bindings -s -M $mode
2	15	----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
7	7	-----> contains -- -h $argv
6	6	-----> contains -- --help $argv
7	7	----> bind --preset $argv \cy yank
7	7	----> bind --preset $argv \ey yank-pop
8	8	----> bind --preset $argv -k right forward-char
8	8	----> bind --preset $argv -k left backward-char
8	8	----> bind --preset $argv \e\[C forward-char
8	8	----> bind --preset $argv \e\[D backward-char
6	6	----> bind --preset $argv \eOC forward-char
7	7	----> bind --preset $argv \eOD backward-char
8	8	----> bind --preset $argv -k ppage beginning-of-history
8	8	----> bind --preset $argv -k npage end-of-history
9	9	----> bind --preset $argv \cx fish_clipboard_copy
8	8	----> bind --preset $argv \cv fish_clipboard_paste
7	7	----> bind --preset $argv \e cancel
9	9	----> bind --preset $argv \t complete
7	7	----> bind --preset $argv \cs pager-toggle-search
8	8	----> bind --preset $argv --key btab complete-and-search
7	7	----> bind --preset $argv \e\n "commandline -i \n"
8	8	----> bind --preset $argv \e\r "commandline -i \n"
7	7	----> bind --preset $argv -k down down-or-search
8	8	----> bind --preset $argv -k up up-or-search
7	7	----> bind --preset $argv \e\[A up-or-search
7	7	----> bind --preset $argv \e\[B down-or-search
7	7	----> bind --preset $argv \eOA up-or-search
7	7	----> bind --preset $argv \eOB down-or-search
9	9	----> bind --preset $argv -k sright forward-bigword
8	8	----> bind --preset $argv -k sleft backward-bigword
7	7	----> bind --preset $argv \e\eOC nextd-or-forward-word
7	7	----> bind --preset $argv \e\eOD prevd-or-backward-word
8	8	----> bind --preset $argv \e\e\[C nextd-or-forward-word
8	8	----> bind --preset $argv \e\e\[D prevd-or-backward-word
8	8	----> bind --preset $argv \eO3C nextd-or-forward-word
7	7	----> bind --preset $argv \eO3D prevd-or-backward-word
7	7	----> bind --preset $argv \e\[3C nextd-or-forward-word
8	8	----> bind --preset $argv \e\[3D prevd-or-backward-word
8	8	----> bind --preset $argv \e\[1\;3C nextd-or-forward-word
7	7	----> bind --preset $argv \e\[1\;3D prevd-or-backward-word
7	7	----> bind --preset $argv \e\[1\;9C nextd-or-forward-word
8	8	----> bind --preset $argv \e\[1\;9D prevd-or-backward-word
8	8	----> bind --preset $argv \e\eOA history-token-search-backward
7	7	----> bind --preset $argv \e\eOB history-token-search-forward
7	7	----> bind --preset $argv \e\e\[A history-token-search-backward
7	7	----> bind --preset $argv \e\e\[B history-token-search-forward
8	8	----> bind --preset $argv \eO3A history-token-search-backward
8	8	----> bind --preset $argv \eO3B history-token-search-forward
7	7	----> bind --preset $argv \e\[3A history-token-search-backward
7	7	----> bind --preset $argv \e\[3B history-token-search-forward
8	8	----> bind --preset $argv \e\[1\;3A history-token-search-backward
7	7	----> bind --preset $argv \e\[1\;3B history-token-search-forward
8	8	----> bind --preset $argv \e\[1\;9A history-token-search-backward
8	8	----> bind --preset $argv \e\[1\;9B history-token-search-forward
7	7	----> bind --preset $argv \e. history-token-search-backward
7	7	----> bind --preset $argv \el __fish_list_current_token
8	8	----> bind --preset $argv \ew __fish_whatis_current_token
8	8	----> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
8	8	----> bind --preset $argv \cc __fish_cancel_commandline
7	7	----> bind --preset $argv \cu backward-kill-line
6	6	----> bind --preset $argv \cw backward-kill-path-component
8	8	----> bind --preset $argv \e\[F end-of-line
8	8	----> bind --preset $argv \e\[H beginning-of-line
8	8	----> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
7	7	----> bind --preset $argv \cd delete-or-exit
8	8	----> bind --preset $argv \es __fish_prepend_sudo
8	8	----> bind --preset $argv -k f1 __fish_man_page
7	7	----> bind --preset $argv \eh __fish_man_page
7	7	----> bind --preset $argv \ep '__fish_paginate'
7	7	----> bind --preset $argv \e\# __fish_toggle_comment_commandline
7	7	----> bind --preset $argv \ee edit_command_buffer
7	7	----> bind --preset $argv \ev edit_command_buffer
39	184	----> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
103	103	-----> bind --list-modes | string match -v paste
10	10	-----> bind --preset -M $mode \e\[I 'emit fish_focus_in'
6	6	-----> bind --preset -M $mode \e\[O false
7	7	-----> bind --preset -M $mode \e\[\?1004h false
7	7	-----> bind --preset -M $mode \e\[I 'emit fish_focus_in'
6	6	-----> bind --preset -M $mode \e\[O false
6	6	-----> bind --preset -M $mode \e\[\?1004h false
35	142	----> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
89	89	-----> bind --list-modes | string match -v paste
10	10	-----> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
8	8	-----> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
6	6	----> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
6	6	----> bind --preset -M paste "" self-insert
6	6	----> bind --preset -M paste \r "commandline -i \n"
7	7	----> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
6	6	----> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
5	5	----> bind --preset -M paste " " self-insert-notfirst
77	1092	---> __fish_shared_key_bindings -s -M $mode
3	15	----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
6	6	-----> contains -- -h $argv
6	6	-----> contains -- --help $argv
8	8	----> bind --preset $argv \cy yank
8	8	----> bind --preset $argv \ey yank-pop
9	9	----> bind --preset $argv -k right forward-char
9	9	----> bind --preset $argv -k left backward-char
8	8	----> bind --preset $argv \e\[C forward-char
7	7	----> bind --preset $argv \e\[D backward-char
7	7	----> bind --preset $argv \eOC forward-char
7	7	----> bind --preset $argv \eOD backward-char
8	8	----> bind --preset $argv -k ppage beginning-of-history
8	8	----> bind --preset $argv -k npage end-of-history
7	7	----> bind --preset $argv \cx fish_clipboard_copy
7	7	----> bind --preset $argv \cv fish_clipboard_paste
7	7	----> bind --preset $argv \e cancel
7	7	----> bind --preset $argv \t complete
7	7	----> bind --preset $argv \cs pager-toggle-search
10	10	----> bind --preset $argv --key btab complete-and-search
8	8	----> bind --preset $argv \e\n "commandline -i \n"
10	10	----> bind --preset $argv \e\r "commandline -i \n"
7	7	----> bind --preset $argv -k down down-or-search
9	9	----> bind --preset $argv -k up up-or-search
8	8	----> bind --preset $argv \e\[A up-or-search
8	8	----> bind --preset $argv \e\[B down-or-search
7	7	----> bind --preset $argv \eOA up-or-search
7	7	----> bind --preset $argv \eOB down-or-search
10	10	----> bind --preset $argv -k sright forward-bigword
9	9	----> bind --preset $argv -k sleft backward-bigword
8	8	----> bind --preset $argv \e\eOC nextd-or-forward-word
8	8	----> bind --preset $argv \e\eOD prevd-or-backward-word
8	8	----> bind --preset $argv \e\e\[C nextd-or-forward-word
8	8	----> bind --preset $argv \e\e\[D prevd-or-backward-word
8	8	----> bind --preset $argv \eO3C nextd-or-forward-word
8	8	----> bind --preset $argv \eO3D prevd-or-backward-word
8	8	----> bind --preset $argv \e\[3C nextd-or-forward-word
8	8	----> bind --preset $argv \e\[3D prevd-or-backward-word
9	9	----> bind --preset $argv \e\[1\;3C nextd-or-forward-word
9	9	----> bind --preset $argv \e\[1\;3D prevd-or-backward-word
9	9	----> bind --preset $argv \e\[1\;9C nextd-or-forward-word
8	8	----> bind --preset $argv \e\[1\;9D prevd-or-backward-word
8	8	----> bind --preset $argv \e\eOA history-token-search-backward
8	8	----> bind --preset $argv \e\eOB history-token-search-forward
8	8	----> bind --preset $argv \e\e\[A history-token-search-backward
9	9	----> bind --preset $argv \e\e\[B history-token-search-forward
8	8	----> bind --preset $argv \eO3A history-token-search-backward
8	8	----> bind --preset $argv \eO3B history-token-search-forward
8	8	----> bind --preset $argv \e\[3A history-token-search-backward
8	8	----> bind --preset $argv \e\[3B history-token-search-forward
9	9	----> bind --preset $argv \e\[1\;3A history-token-search-backward
9	9	----> bind --preset $argv \e\[1\;3B history-token-search-forward
9	9	----> bind --preset $argv \e\[1\;9A history-token-search-backward
9	9	----> bind --preset $argv \e\[1\;9B history-token-search-forward
7	7	----> bind --preset $argv \e. history-token-search-backward
7	7	----> bind --preset $argv \el __fish_list_current_token
8	8	----> bind --preset $argv \ew __fish_whatis_current_token
9	9	----> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
7	7	----> bind --preset $argv \cc __fish_cancel_commandline
7	7	----> bind --preset $argv \cu backward-kill-line
7	7	----> bind --preset $argv \cw backward-kill-path-component
8	8	----> bind --preset $argv \e\[F end-of-line
8	8	----> bind --preset $argv \e\[H beginning-of-line
9	9	----> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
7	7	----> bind --preset $argv \cd delete-or-exit
8	8	----> bind --preset $argv \es __fish_prepend_sudo
9	9	----> bind --preset $argv -k f1 __fish_man_page
8	8	----> bind --preset $argv \eh __fish_man_page
8	8	----> bind --preset $argv \ep '__fish_paginate'
8	8	----> bind --preset $argv \e\# __fish_toggle_comment_commandline
7	7	----> bind --preset $argv \ee edit_command_buffer
8	8	----> bind --preset $argv \ev edit_command_buffer
46	240	----> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
131	131	-----> bind --list-modes | string match -v paste
10	10	-----> bind --preset -M $mode \e\[I 'emit fish_focus_in'
6	6	-----> bind --preset -M $mode \e\[O false
6	6	-----> bind --preset -M $mode \e\[\?1004h false
6	6	-----> bind --preset -M $mode \e\[I 'emit fish_focus_in'
6	6	-----> bind --preset -M $mode \e\[O false
6	6	-----> bind --preset -M $mode \e\[\?1004h false
8	8	-----> bind --preset -M $mode \e\[I 'emit fish_focus_in'
7	7	-----> bind --preset -M $mode \e\[O false
8	8	-----> bind --preset -M $mode \e\[\?1004h false
38	179	----> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
113	113	-----> bind --list-modes | string match -v paste
11	11	-----> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
8	8	-----> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
9	9	-----> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
6	6	----> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
5	5	----> bind --preset -M paste "" self-insert
6	6	----> bind --preset -M paste \r "commandline -i \n"
6	6	----> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
6	6	----> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
5	5	----> bind --preset -M paste " " self-insert-notfirst
6	6	--> bind -s --preset -M insert \r execute
6	6	--> bind -s --preset -M insert \n execute
6	6	--> bind -s --preset -M insert "" self-insert
7	7	--> bind -s --preset -M insert " " self-insert expand-abbr
7	7	--> bind -s --preset -M insert \e "if commandline -P; commandline -f cancel; else; set fish_bind_mode default; commandline -f backward-char repaint-mode; end"
5	5	--> bind -s --preset :q exit
6	6	--> bind -s --preset -m insert \cc __fish_cancel_commandline
5	5	--> bind -s --preset -M default h backward-char
7	7	--> bind -s --preset -M default l forward-char
7	7	--> bind -s --preset -m insert \n execute
7	7	--> bind -s --preset -m insert \r execute
7	7	--> bind -s --preset -m insert i repaint-mode
6	6	--> bind -s --preset -m insert I beginning-of-line repaint-mode
6	6	--> bind -s --preset -m insert a forward-char repaint-mode
6	6	--> bind -s --preset -m insert A end-of-line repaint-mode
6	6	--> bind -s --preset -m visual v begin-selection repaint-mode
6	6	--> bind -s --preset gg beginning-of-buffer
6	6	--> bind -s --preset G end-of-buffer
11	25	--> for key in $eol_keys
        bind -s --preset $key end-of-line
    ...
7	7	---> bind -s --preset $key end-of-line
7	7	---> bind -s --preset $key end-of-line
8	29	--> for key in $bol_keys
        bind -s --preset $key beginning-of-line
    ...
7	7	---> bind -s --preset $key beginning-of-line
7	7	---> bind -s --preset $key beginning-of-line
7	7	---> bind -s --preset $key beginning-of-line
5	5	--> bind -s --preset u history-search-backward
6	6	--> bind -s --preset \cr history-search-forward
5	5	--> bind -s --preset [ history-token-search-backward
5	5	--> bind -s --preset ] history-token-search-forward
6	6	--> bind -s --preset k up-or-search
5	5	--> bind -s --preset j down-or-search
5	5	--> bind -s --preset b backward-word
6	6	--> bind -s --preset B backward-bigword
6	6	--> bind -s --preset ge backward-word
5	5	--> bind -s --preset gE backward-bigword
5	5	--> bind -s --preset w forward-word forward-char
6	6	--> bind -s --preset W forward-bigword forward-char
6	6	--> bind -s --preset e forward-char forward-word backward-char
6	6	--> bind -s --preset E forward-bigword backward-char
15	15	--> bind -s --preset -M insert -k home beginning-of-line 2>/dev/null
10	10	--> bind -s --preset -M default -k home beginning-of-line 2>/dev/null
9	9	--> bind -s --preset -M insert -k end end-of-line 2>/dev/null
9	9	--> bind -s --preset -M default -k end end-of-line 2>/dev/null
6	6	--> bind -s --preset -M default x delete-char forward-char backward-char
6	6	--> bind -s --preset -M default X backward-delete-char
9	9	--> bind -s --preset -M insert -k dc delete-char forward-char backward-char
9	9	--> bind -s --preset -M default -k dc delete-char forward-char backward-char
7	7	--> bind -s --preset -M insert -k backspace backward-delete-char
6	6	--> bind -s --preset -M default -k backspace backward-char
7	7	--> bind -s --preset -M insert \ch backward-delete-char
14	14	--> bind -s --preset -M default \ch backward-char
6	6	--> bind -s --preset -M insert \x7f backward-delete-char
6	6	--> bind -s --preset -M default \x7f backward-char
8	8	--> bind -s --preset -M insert \e\[3\;2~ backward-delete-char
8	8	--> bind -s --preset -M default \e\[3\;2~ backward-delete-char
5	5	--> bind -s --preset dd kill-whole-line
5	5	--> bind -s --preset D kill-line
7	7	--> bind -s --preset d\$ kill-line
7	7	--> bind -s --preset d\^ backward-kill-line
6	6	--> bind -s --preset d0 backward-kill-line
5	5	--> bind -s --preset dw kill-word
6	6	--> bind -s --preset dW kill-bigword
8	8	--> bind -s --preset diw forward-char forward-char backward-word kill-word
7	7	--> bind -s --preset diW forward-char forward-char backward-bigword kill-bigword
7	7	--> bind -s --preset daw forward-char forward-char backward-word kill-word
7	7	--> bind -s --preset daW forward-char forward-char backward-bigword kill-bigword
6	6	--> bind -s --preset de kill-word
6	6	--> bind -s --preset dE kill-bigword
6	6	--> bind -s --preset db backward-kill-word
7	7	--> bind -s --preset dB backward-kill-bigword
7	7	--> bind -s --preset dge backward-kill-word
7	7	--> bind -s --preset dgE backward-kill-bigword
7	7	--> bind -s --preset df begin-selection forward-jump kill-selection end-selection
7	7	--> bind -s --preset dt begin-selection forward-jump backward-char kill-selection end-selection
7	7	--> bind -s --preset dF begin-selection backward-jump kill-selection end-selection
7	7	--> bind -s --preset dT begin-selection backward-jump forward-char kill-selection end-selection
7	7	--> bind -s --preset -m insert s delete-char repaint-mode
7	7	--> bind -s --preset -m insert S kill-whole-line repaint-mode
7	7	--> bind -s --preset -m insert cc kill-whole-line repaint-mode
7	7	--> bind -s --preset -m insert C kill-line repaint-mode
8	8	--> bind -s --preset -m insert c\$ kill-line repaint-mode
8	8	--> bind -s --preset -m insert c\^ backward-kill-line repaint-mode
7	7	--> bind -s --preset -m insert cw kill-word repaint-mode
6	6	--> bind -s --preset -m insert cW kill-bigword repaint-mode
8	8	--> bind -s --preset -m insert ciw forward-char forward-char backward-word kill-word repaint-mode
9	9	--> bind -s --preset -m insert ciW forward-char forward-char backward-bigword kill-bigword repaint-mode
8	8	--> bind -s --preset -m insert caw forward-char forward-char backward-word kill-word repaint-mode
8	8	--> bind -s --preset -m insert caW forward-char forward-char backward-bigword kill-bigword repaint-mode
7	7	--> bind -s --preset -m insert ce kill-word repaint-mode
10	10	--> bind -s --preset -m insert cE kill-bigword repaint-mode
7	7	--> bind -s --preset -m insert cb backward-kill-word repaint-mode
7	7	--> bind -s --preset -m insert cB backward-kill-bigword repaint-mode
7	7	--> bind -s --preset -m insert cge backward-kill-word repaint-mode
7	7	--> bind -s --preset -m insert cgE backward-kill-bigword repaint-mode
6	6	--> bind -s --preset '~' capitalize-word
6	6	--> bind -s --preset gu downcase-word
6	6	--> bind -s --preset gU upcase-word
6	6	--> bind -s --preset J end-of-line delete-char
6	6	--> bind -s --preset K 'man (commandline -t) 2>/dev/null; or echo -n \a'
7	7	--> bind -s --preset yy kill-whole-line yank
6	6	--> bind -s --preset Y kill-whole-line yank
8	8	--> bind -s --preset y\$ kill-line yank
8	8	--> bind -s --preset y\^ backward-kill-line yank
7	7	--> bind -s --preset yw kill-word yank
7	7	--> bind -s --preset yW kill-bigword yank
8	8	--> bind -s --preset yiw forward-char forward-char backward-word kill-word yank
7	7	--> bind -s --preset yiW forward-char forward-char backward-bigword kill-bigword yank
7	7	--> bind -s --preset yaw forward-char forward-char backward-word kill-word yank
8	8	--> bind -s --preset yaW forward-char forward-char backward-bigword kill-bigword yank
7	7	--> bind -s --preset ye kill-word yank
7	7	--> bind -s --preset yE kill-bigword yank
7	7	--> bind -s --preset yb backward-kill-word yank
7	7	--> bind -s --preset yB backward-kill-bigword yank
7	7	--> bind -s --preset yge backward-kill-word yank
6	6	--> bind -s --preset ygE backward-kill-bigword yank
6	6	--> bind -s --preset f forward-jump
6	6	--> bind -s --preset F backward-jump
5	5	--> bind -s --preset t forward-jump-till
5	5	--> bind -s --preset T backward-jump-till
6	6	--> bind -s --preset ';' repeat-jump
6	6	--> bind -s --preset , repeat-jump-reverse
6	6	--> bind -s --preset p yank
6	6	--> bind -s --preset P backward-char yank
6	6	--> bind -s --preset gp yank-pop
8	8	--> bind -s --preset '"*p' "commandline -i ( xsel -p; echo )[1]"
8	8	--> bind -s --preset '"*P' backward-char "commandline -i ( xsel -p; echo )[1]"
6	6	--> bind -s --preset -m replace_one r repaint-mode
7	7	--> bind -s --preset -M replace_one -m default '' delete-char self-insert backward-char repaint-mode
9	9	--> bind -s --preset -M replace_one -m default \r 'commandline -f delete-char; commandline -i \n; commandline -f backward-char; commandline -f repaint-mode'
8	8	--> bind -s --preset -M replace_one -m default \e cancel repaint-mode
6	6	--> bind -s --preset -m replace R repaint-mode
6	6	--> bind -s --preset -M replace '' delete-char self-insert
8	8	--> bind -s --preset -M replace -m insert \r execute repaint-mode
8	8	--> bind -s --preset -M replace -m default \e cancel repaint-mode
7	7	--> bind -s --preset -M replace -k backspace backward-char
6	6	--> bind -s --preset -M visual h backward-char
6	6	--> bind -s --preset -M visual l forward-char
6	6	--> bind -s --preset -M visual k up-line
6	6	--> bind -s --preset -M visual j down-line
6	6	--> bind -s --preset -M visual b backward-word
6	6	--> bind -s --preset -M visual B backward-bigword
6	6	--> bind -s --preset -M visual ge backward-word
7	7	--> bind -s --preset -M visual gE backward-bigword
7	7	--> bind -s --preset -M visual w forward-word
7	7	--> bind -s --preset -M visual W forward-bigword
6	6	--> bind -s --preset -M visual e forward-word
8	8	--> bind -s --preset -M visual E forward-bigword
7	7	--> bind -s --preset -M visual o swap-selection-start-stop repaint-mode
7	7	--> bind -s --preset -M visual f forward-jump
6	6	--> bind -s --preset -M visual t forward-jump-till
6	6	--> bind -s --preset -M visual F backward-jump
6	6	--> bind -s --preset -M visual T backward-jump-till
16	31	--> for key in $eol_keys
        bind -s --preset -M visual $key end-of-line
    ...
7	7	---> bind -s --preset -M visual $key end-of-line
8	8	---> bind -s --preset -M visual $key end-of-line
8	32	--> for key in $bol_keys
        bind -s --preset -M visual $key beginning-of-line
    ...
8	8	---> bind -s --preset -M visual $key beginning-of-line
8	8	---> bind -s --preset -M visual $key beginning-of-line
8	8	---> bind -s --preset -M visual $key beginning-of-line
8	8	--> bind -s --preset -M visual -m insert c kill-selection end-selection repaint-mode
8	8	--> bind -s --preset -M visual -m default d kill-selection end-selection repaint-mode
7	7	--> bind -s --preset -M visual -m default x kill-selection end-selection repaint-mode
8	8	--> bind -s --preset -M visual -m default X kill-whole-line end-selection repaint-mode
8	8	--> bind -s --preset -M visual -m default y kill-selection yank end-selection repaint-mode
9	9	--> bind -s --preset -M visual -m default '"*y' "commandline -s | xsel -p; commandline -f end-selection repaint-mode"
7	7	--> bind -s --preset -M visual -m default \cc end-selection repaint-mode
6	6	--> bind -s --preset -M visual -m default \e end-selection repaint-mode
7	7	--> bind -s --preset -M default \# __fish_toggle_comment_commandline
7	7	--> bind -s --preset -M visual \# __fish_toggle_comment_commandline
8	8	--> bind -s --preset -M replace \# __fish_toggle_comment_commandline
60	538	--> fish_vi_cursor
214	219	---> source /usr/share/fish/functions/fish_vi_cursor.fish
5	5	----> function fish_vi_cursor -d 'Set cursor shape for different vi modes'
    # If we're not interactive, there is effectively no bind mode.
    if not status is-interactive
        return
    end

    # This is hard to test in expect, since the exact sequences depend on the environment.
    # Instead disable it.
    if set -q FISH_UNIT_TESTS_RUNNING
        return
    end

    # Emacs Makes All Cursors Suck
    if set -q INSIDE_EMACS
        return
    end

    # vte-based terms set $TERM = xterm*, but only gained support in 2015.
    # From https://bugzilla.gnome.org/show_bug.cgi?id=720821, it appears it was version 0.40.0
    if set -q VTE_VERSION
        and test "$VTE_VERSION" -lt 4000 2>/dev/null
        return
    end

    # Similarly, genuine XTerm can do it since v280.
    if set -q XTERM_VERSION
        and not test (string replace -r "XTerm\((\d+)\)" '$1' -- "$XTERM_VERSION") -ge 280 2>/dev/null
        return
    end

    # We need one of these terms.
    # It would be lovely if we could rely on terminfo, but:
    # - The "Ss" entry isn't a thing in macOS' old and crusty terminfo
    # - It is set for xterm, and everyone and their dog claims to be xterm
    #
    # So we just don't care about $TERM, unless it is one of the few terminals that actually have their own entry.
    #
    # Note: Previous versions also checked $TMUX, and made sure that then $TERM was screen* or tmux*.
    # We don't care, since we *cannot* handle term-in-a-terms 100% correctly.
    if not set -q KONSOLE_PROFILE_NAME
        and not set -q ITERM_PROFILE
        and not set -q VTE_VERSION # which version is already checked above
        and not set -q XTERM_VERSION
        and not string match -rq '^st(-.*)$' -- $TERM
        and not string match -q 'xterm-kitty*' -- $TERM
        and not string match -q 'rxvt*' -- $TERM
        return
    end

    # HACK: Explicitly disable on ITERM because of #3696, which is weirdness with multi-line prompts.
    # We allow an explicit "--force-iterm" as first argument to skip this.
    # It's recommended only if you don't use a multi-line prompt.
    if contains -- $argv[1] --force-iterm
        set -e argv[1]
    else if set -q ITERM_PROFILE
        return
    end

    set -l terminal $argv[1]
    set -q terminal[1]
    or set terminal auto

    set -l function
    switch "$terminal"
        case auto
            # TODO: Konsole as of 18.08 knows the xterm sequences,
            # but there's still bugs with it (as of konsole 19.04.0).
            #
            # If it is fixed, we'd have to read $KONSOLE_VERSION for a while,
            # though that was only introduced in 18.08 as well.
            if set -q KONSOLE_PROFILE_NAME
                set function __fish_cursor_konsole
            else if set -q ITERM_PROFILE
                set function __fish_cursor_1337
            else
                set function __fish_cursor_xterm
            end
        case konsole
            set function __fish_cursor_konsole
        case xterm
            set function __fish_cursor_xterm
    end

    set -l tmux_prefix
    set -l tmux_postfix
    if set -q TMUX
        set tmux_prefix echo -ne "'\ePtmux;\e'"
        set tmux_postfix echo -ne "'\e\\\\'"
    end

    set -q fish_cursor_unknown
    or set -g fish_cursor_unknown block blink

    echo "
          function fish_vi_cursor_handle --on-variable fish_bind_mode --on-event fish_postexec --on-event fish_focus_in
              set -l varname fish_cursor_\$fish_bind_mode
              if not set -q \$varname
                set varname fish_cursor_unknown
              end
              $tmux_prefix
              $function \$\$varname
              $tmux_postfix
          end
         " | source

    echo "
          function fish_vi_cursor_handle_preexec --on-event fish_preexec
              set -l varname fish_cursor_default
              if not set -q \$varname
                set varname fish_cursor_unknown
              end
              $tmux_prefix
              $function \$\$varname
              $tmux_postfix
          end
         " | source
...
1	6	---> if not status is-interactive
        return
    ...
5	5	----> not status is-interactive
1	6	---> if set -q FISH_UNIT_TESTS_RUNNING
        return
    ...
5	5	----> set -q FISH_UNIT_TESTS_RUNNING
0	4	---> if set -q INSIDE_EMACS
        return
    ...
4	4	----> set -q INSIDE_EMACS
1	4	---> if set -q VTE_VERSION
        and test "$VTE_VERSION" -lt 4000 2>/dev/null
        return
    ...
3	3	----> set -q VTE_VERSION
1	4	---> if set -q XTERM_VERSION
        and not test (string replace -r "XTerm\((\d+)\)" '$1' -- "$XTERM_VERSION") -ge 280 2>/dev/null
        return
    ...
3	3	----> set -q XTERM_VERSION
4	37	---> if not set -q KONSOLE_PROFILE_NAME
        and not set -q ITERM_PROFILE
        and not set -q VTE_VERSION # which version is already checked above
        and not set -q XTERM_VERSION
        and not string match -rq '^st(-.*)$' -- $TERM
        and not string match -q 'xterm-kitty*' -- $TERM
        and not string match -q 'rxvt*' -- $TERM
        return
    ...
3	3	----> not set -q KONSOLE_PROFILE_NAME
3	3	----> not set -q ITERM_PROFILE
3	3	----> not set -q VTE_VERSION
3	3	----> not set -q XTERM_VERSION
14	14	----> not string match -rq '^st(-.*)$' -- $TERM
7	7	----> not string match -q 'xterm-kitty*' -- $TERM
2	11	---> if contains -- $argv[1] --force-iterm
        set -e argv[1]
    else if set -q ITERM_PROFILE
        return
    ...
6	6	----> contains -- $argv[1] --force-iterm
3	3	----> set -q ITERM_PROFILE
6	6	---> set -l terminal $argv[1]
4	4	---> set -q terminal[1]
4	4	---> set terminal auto
4	4	---> set -l function
6	21	---> switch "$terminal"
        case auto
            # TODO: Konsole as of 18.08 knows the xterm sequences,
            # but there's still bugs with it (as of konsole 19.04.0).
            #
            # If it is fixed, we'd have to read $KONSOLE_VERSION for a while,
            # though that was only introduced in 18.08 as well.
            if set -q KONSOLE_PROFILE_NAME
                set function __fish_cursor_konsole
            else if set -q ITERM_PROFILE
                set function __fish_cursor_1337
            else
                set function __fish_cursor_xterm
            end
        case konsole
            set function __fish_cursor_konsole
        case xterm
            set function __fish_cursor_xterm
    ...
5	15	----> if set -q KONSOLE_PROFILE_NAME
                set function __fish_cursor_konsole
            else if set -q ITERM_PROFILE
                set function __fish_cursor_1337
            else
                set function __fish_cursor_xterm
            ...
3	3	-----> set -q KONSOLE_PROFILE_NAME
3	3	-----> set -q ITERM_PROFILE
4	4	-----> set function __fish_cursor_xterm
4	4	---> set -l tmux_prefix
4	4	---> set -l tmux_postfix
2	5	---> if set -q TMUX
        set tmux_prefix echo -ne "'\ePtmux;\e'"
        set tmux_postfix echo -ne "'\e\\\\'"
    ...
3	3	----> set -q TMUX
3	3	---> set -q fish_cursor_unknown
5	5	---> set -g fish_cursor_unknown block blink
66	73	---> echo "
          function fish_vi_cursor_handle --on-variable fish_bind_mode --on-event fish_postexec --on-event fish_focus_in
              set -l varname fish_cursor_\$fish_bind_mode
              if not set -q \$varname
                set varname fish_cursor_unknown
              end
              $tmux_prefix
              $function \$\$varname
              $tmux_postfix
          end
         " | source
7	7	----> function fish_vi_cursor_handle --on-variable fish_bind_mode --on-event fish_postexec --on-event fish_focus_in
              set -l varname fish_cursor_$fish_bind_mode
              if not set -q $varname
                set varname fish_cursor_unknown
              end
              
              __fish_cursor_xterm $$varname
              
          ...
50	54	---> echo "
          function fish_vi_cursor_handle_preexec --on-event fish_preexec
              set -l varname fish_cursor_default
              if not set -q \$varname
                set varname fish_cursor_unknown
              end
              $tmux_prefix
              $function \$\$varname
              $tmux_postfix
          end
         " | source
4	4	----> function fish_vi_cursor_handle_preexec --on-event fish_preexec
              set -l varname fish_cursor_default
              if not set -q $varname
                set varname fish_cursor_unknown
              end
              
              __fish_cursor_xterm $$varname
              
          ...
15	217	--> set fish_bind_mode $init_mode
9	202	---> fish_vi_cursor_handle VARIABLE SET fish_bind_mode
6	6	----> set -l varname fish_cursor_$fish_bind_mode
1	10	----> if not set -q $varname
                set varname fish_cursor_unknown
              ...
5	5	-----> not set -q $varname
4	4	-----> set varname fish_cursor_unknown
44	177	----> __fish_cursor_xterm $$varname
49	54	-----> source /usr/share/fish/functions/__fish_cursor_xterm.fish
5	5	------> function __fish_cursor_xterm -d 'Set cursor (xterm)'
    set -l shape $argv[1]

    switch "$shape"
        case block
            set shape 2
        case underscore
            set shape 4
        case line
            set shape 6
    end
    if contains blink $argv
        set shape (math $shape - 1)
    end
    echo -en "\e[$shape q"
...
7	7	-----> set -l shape $argv[1]
4	7	-----> switch "$shape"
        case block
            set shape 2
        case underscore
            set shape 4
        case line
            set shape 6
    ...
3	3	------> set shape 2
2	54	-----> if contains blink $argv
        set shape (math $shape - 1)
    ...
6	6	------> contains blink $argv
22	46	------> set shape (math $shape - 1)
24	24	-------> math $shape - 1
11	11	-----> echo -en "\e[$shape q"
7	7	-> set fish_greeting
5	5	-> set fish_cursor_default     block      blink
5	5	-> set fish_cursor_insert      line       blink
6	6	-> set fish_cursor_replace_one underscore blink
5	5	-> set fish_cursor_visual      block
6	6	-> set fish_ambiguous_width    1
43	253	-> export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border=sharp'
81	87	--> source /usr/share/fish/functions/export.fish
6	6	---> function export --description 'Set env variable. Alias for `set -gx` for bash compatibility.'
    if not set -q argv[1]
        set -x
        return 0
    end
    for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    end
...
2	7	--> if not set -q argv[1]
        set -x
        return 0
    ...
5	5	---> not set -q argv[1]
9	116	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
25	37	---> set -l v (string split -m 1 "=" -- $arg)
12	12	----> string split -m 1 "=" -- $arg
18	70	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
21	21	----> count $v
4	31	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
7	7	-----> contains -- $v[1] PATH CDPATH MANPATH
12	12	-----> true
8	8	-----> set -gx $v[1] $v[2]
47	556	-> alias v="nvim"
185	190	--> source /usr/share/fish/functions/alias.fish
5	5	---> function alias --description 'Creates a function wrapping a command'
    set -l options 'h/help' 's/save'
    argparse -n alias --max-args=2 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help alias
        return 0
    end

    set -l name
    set -l body
    set -l prefix
    set -l first_word
    set -l wrapped_cmd

    if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    end

    # sanity check
    if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    end

    # Extract the first command from the body.
    printf '%s\n' $body | read -lt first_word body

    # Prevent the alias from immediately running into an infinite recursion if
    # $body starts with the same command as $name.
    if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    end
    set -l cmd_string (string escape -- "alias $argv")
    set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
    echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
    if set -q _flag_save
        funcsave $name
    end
    #echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end"
...
7	7	--> set -l options 'h/help' 's/save'
12	12	--> argparse -n alias --max-args=2 $options -- $argv
1	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
4	4	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
5	5	--> set -l first_word
4	4	--> set -l wrapped_cmd
6	59	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
25	35	---> set -l tmp (string split -m 1 "=" -- $argv) ""
10	10	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
2	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
5	5	---> test -z "$body"
40	40	--> printf '%s\n' $body | read -lt first_word body
2	9	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
7	7	---> test $first_word = $name
32	40	--> set -l cmd_string (string escape -- "alias $argv")
8	8	---> string escape -- "alias $argv"
24	64	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
40	40	---> string join ' ' -- $first_word $body | string escape
38	44	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
6	6	---> function v --wraps nvim --description 'alias v=nvim';  nvim  $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
19	327	-> alias vf="nvim (fzf)"
7	7	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
2	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
6	61	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
27	37	---> set -l tmp (string split -m 1 "=" -- $argv) ""
10	10	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
2	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
6	6	---> test -z "$name"
4	4	---> test -z "$body"
25	25	--> printf '%s\n' $body | read -lt first_word body
2	9	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
7	7	---> test $first_word = $name
28	38	--> set -l cmd_string (string escape -- "alias $argv")
10	10	---> string escape -- "alias $argv"
23	65	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
42	42	---> string join ' ' -- $first_word $body | string escape
42	49	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
7	7	---> function vf --wraps 'nvim (fzf)' --description 'alias vf=nvim (fzf)';  nvim (fzf) $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
22	329	-> alias lf="ranger"
6	6	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
1	4	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
5	60	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
3	3	---> not set -q argv[1]
4	4	---> not set -q argv[2]
27	37	---> set -l tmp (string split -m 1 "=" -- $argv) ""
10	10	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
3	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
4	4	---> test -z "$body"
22	22	--> printf '%s\n' $body | read -lt first_word body
2	8	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
6	6	---> test $first_word = $name
23	32	--> set -l cmd_string (string escape -- "alias $argv")
9	9	---> string escape -- "alias $argv"
42	75	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
33	33	---> string join ' ' -- $first_word $body | string escape
45	51	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
6	6	---> function lf --wraps ranger --description 'alias lf=ranger';  ranger  $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
26	349	-> alias vinit="nvim ~/.config/nvim/init.vim"
6	6	--> set -l options 'h/help' 's/save'
10	10	--> argparse -n alias --max-args=2 $options -- $argv
1	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
4	4	---> set -q _flag_help
4	4	--> set -l name
3	3	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
6	71	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
34	48	---> set -l tmp (string split -m 1 "=" -- $argv) ""
14	14	----> string split -m 1 "=" -- $argv
5	5	---> set name $tmp[1]
5	5	---> set body $tmp[2]
2	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
6	6	---> test -z "$name"
4	4	---> test -z "$body"
35	35	--> printf '%s\n' $body | read -lt first_word body
1	8	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
7	7	---> test $first_word = $name
25	34	--> set -l cmd_string (string escape -- "alias $argv")
9	9	---> string escape -- "alias $argv"
25	66	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
41	41	---> string join ' ' -- $first_word $body | string escape
45	52	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
7	7	---> function vinit --wraps 'nvim ~/.config/nvim/init.vim' --description 'alias vinit=nvim ~/.config/nvim/init.vim';  nvim ~/.config/nvim/init.vim $argv; ...
1	5	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
23	311	-> alias r="radian"
6	6	--> set -l options 'h/help' 's/save'
10	10	--> argparse -n alias --max-args=2 $options -- $argv
1	4	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
3	3	--> set -l wrapped_cmd
7	63	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
3	3	---> not set -q argv[1]
3	3	---> not set -q argv[2]
29	39	---> set -l tmp (string split -m 1 "=" -- $argv) ""
10	10	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
3	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
4	4	---> test -z "$body"
23	23	--> printf '%s\n' $body | read -lt first_word body
2	8	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
6	6	---> test $first_word = $name
27	37	--> set -l cmd_string (string escape -- "alias $argv")
10	10	---> string escape -- "alias $argv"
21	56	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
35	35	---> string join ' ' -- $first_word $body | string escape
39	44	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
5	5	---> function r --wraps radian --description 'alias r=radian';  radian  $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
26	314	-> alias py="ipython"
6	6	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
2	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
3	3	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
6	60	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
27	36	---> set -l tmp (string split -m 1 "=" -- $argv) ""
9	9	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
2	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
6	6	---> test -z "$name"
4	4	---> test -z "$body"
24	24	--> printf '%s\n' $body | read -lt first_word body
1	7	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
6	6	---> test $first_word = $name
22	30	--> set -l cmd_string (string escape -- "alias $argv")
8	8	---> string escape -- "alias $argv"
23	58	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
35	35	---> string join ' ' -- $first_word $body | string escape
45	50	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
5	5	---> function py --wraps ipython --description 'alias py=ipython';  ipython  $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
21	306	-> alias la="ncdu"
6	6	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
1	4	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
6	63	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
28	39	---> set -l tmp (string split -m 1 "=" -- $argv) ""
11	11	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
3	13	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
5	5	---> test -z "$body"
23	23	--> printf '%s\n' $body | read -lt first_word body
1	8	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
7	7	---> test $first_word = $name
23	31	--> set -l cmd_string (string escape -- "alias $argv")
8	8	---> string escape -- "alias $argv"
23	57	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
34	34	---> string join ' ' -- $first_word $body | string escape
39	44	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
5	5	---> function la --wraps ncdu --description 'alias la=ncdu';  ncdu  $argv; ...
1	5	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
24	306	-> alias rm="trashf"
6	6	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
2	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
3	3	--> set -l wrapped_cmd
6	59	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
25	35	---> set -l tmp (string split -m 1 "=" -- $argv) ""
10	10	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
4	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
4	4	---> test -z "$name"
4	4	---> test -z "$body"
24	24	--> printf '%s\n' $body | read -lt first_word body
1	7	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
6	6	---> test $first_word = $name
22	31	--> set -l cmd_string (string escape -- "alias $argv")
9	9	---> string escape -- "alias $argv"
23	59	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
36	36	---> string join ' ' -- $first_word $body | string escape
39	44	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
5	5	---> function rm --wraps trashf --description 'alias rm=trashf';  trashf  $argv; ...
1	5	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
25	365	-> alias empty='echo -n Emptying the Bin | pv -qL 10 && command rm -rf ~/.local/share/Trash/files/*'
6	6	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
1	4	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
3	3	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
7	65	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
3	3	---> not set -q argv[1]
4	4	---> not set -q argv[2]
30	41	---> set -l tmp (string split -m 1 "=" -- $argv) ""
11	11	----> string split -m 1 "=" -- $argv
5	5	---> set name $tmp[1]
5	5	---> set body $tmp[2]
2	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
5	5	---> test -z "$body"
41	41	--> printf '%s\n' $body | read -lt first_word body
1	7	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
6	6	---> test $first_word = $name
25	36	--> set -l cmd_string (string escape -- "alias $argv")
11	11	---> string escape -- "alias $argv"
24	65	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
41	41	---> string join ' ' -- $first_word $body | string escape
61	68	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
7	7	---> function empty --wraps 'echo -n Emptying the Bin | pv -qL 10 && command rm -rf ~/.local/share/Trash/files/*' --description 'alias empty=echo -n Emptying the Bin | pv -qL 10 && command rm -rf ~/.local/share/Trash/files/*';  echo -n Emptying the Bin | pv -qL 10 && command rm -rf ~/.local/share/Trash/files/* $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
25	353	-> alias conf="cd $HOME/dotfiles/; nvim (fzf)"
7	7	--> set -l options 'h/help' 's/save'
10	10	--> argparse -n alias --max-args=2 $options -- $argv
2	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
3	3	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
6	70	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
35	46	---> set -l tmp (string split -m 1 "=" -- $argv) ""
11	11	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
2	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
5	5	---> test -z "$body"
31	31	--> printf '%s\n' $body | read -lt first_word body
2	8	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
6	6	---> test $first_word = $name
30	39	--> set -l cmd_string (string escape -- "alias $argv")
9	9	---> string escape -- "alias $argv"
25	66	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
41	41	---> string join ' ' -- $first_word $body | string escape
50	56	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
6	6	---> function conf --wraps 'cd /home/cjber/dotfiles/; nvim (fzf)' --description 'alias conf=cd /home/cjber/dotfiles/; nvim (fzf)';  cd /home/cjber/dotfiles/; nvim (fzf) $argv; ...
1	5	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
38	666	-> alias bat="bat --style=grid,numbers --theme TwoDark"
7	7	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
2	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
3	3	--> set -l wrapped_cmd
6	63	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
28	39	---> set -l tmp (string split -m 1 "=" -- $argv) ""
11	11	----> string split -m 1 "=" -- $argv
6	6	---> set name $tmp[1]
5	5	---> set body $tmp[2]
2	12	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
5	5	---> test -z "$body"
30	30	--> printf '%s\n' $body | read -lt first_word body
4	117	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
6	6	---> test $first_word = $name
3	107	---> if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        ...
76	99	----> contains $name (builtin --names)
23	23	-----> builtin --names
5	5	----> set prefix command
26	36	--> set -l cmd_string (string escape -- "alias $argv")
10	10	---> string escape -- "alias $argv"
82	168	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
86	86	---> string join ' ' -- $first_word $body | string escape
129	146	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
17	17	---> function bat --wraps 'bat --style=grid,numbers --theme TwoDark' --description 'alias bat=bat --style=grid,numbers --theme TwoDark'; command bat --style=grid,numbers --theme TwoDark $argv; ...
4	14	--> if set -q _flag_save
        funcsave $name
    ...
10	10	---> set -q _flag_save
37	253	-> export DOTREPO=$HOME/dotfiles
2	11	--> if not set -q argv[1]
        set -x
        return 0
    ...
9	9	---> not set -q argv[1]
17	205	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
59	82	---> set -l v (string split -m 1 "=" -- $arg)
23	23	----> string split -m 1 "=" -- $arg
41	106	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
19	19	----> count $v
9	46	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
14	14	-----> contains -- $v[1] PATH CDPATH MANPATH
7	7	-----> true
16	16	-----> set -gx $v[1] $v[2]
47	885	-> alias dotdrop='dotdrop --cfg=$HOME/dotfiles/config.yaml'
13	13	--> set -l options 'h/help' 's/save'
24	24	--> argparse -n alias --max-args=2 $options -- $argv
4	11	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
7	7	---> set -q _flag_help
8	8	--> set -l name
8	8	--> set -l body
8	8	--> set -l prefix
8	8	--> set -l first_word
8	8	--> set -l wrapped_cmd
11	126	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
7	7	---> not set -q argv[1]
6	6	---> not set -q argv[2]
58	80	---> set -l tmp (string split -m 1 "=" -- $argv) ""
22	22	----> string split -m 1 "=" -- $argv
12	12	---> set name $tmp[1]
10	10	---> set body $tmp[2]
4	25	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
12	12	---> test -z "$name"
9	9	---> test -z "$body"
74	74	--> printf '%s\n' $body | read -lt first_word body
7	203	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
13	13	---> test $first_word = $name
8	183	---> if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        ...
125	164	----> contains $name (builtin --names)
39	39	-----> builtin --names
11	11	----> set prefix command
47	67	--> set -l cmd_string (string escape -- "alias $argv")
20	20	---> string escape -- "alias $argv"
53	138	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
85	85	---> string join ' ' -- $first_word $body | string escape
91	105	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
14	14	---> function dotdrop --wraps 'dotdrop --cfg=$HOME/dotfiles/config.yaml' --description 'alias dotdrop=dotdrop --cfg=$HOME/dotfiles/config.yaml'; command dotdrop --cfg=$HOME/dotfiles/config.yaml $argv; ...
4	12	--> if set -q _flag_save
        funcsave $name
    ...
8	8	---> set -q _flag_save
37	579	-> alias dotgit="git -C $DOTREPO"
13	13	--> set -l options 'h/help' 's/save'
22	22	--> argparse -n alias --max-args=2 $options -- $argv
3	10	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
7	7	---> set -q _flag_help
8	8	--> set -l name
8	8	--> set -l body
8	8	--> set -l prefix
9	9	--> set -l first_word
9	9	--> set -l wrapped_cmd
12	125	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
7	7	---> not set -q argv[1]
7	7	---> not set -q argv[2]
55	77	---> set -l tmp (string split -m 1 "=" -- $argv) ""
22	22	----> string split -m 1 "=" -- $argv
12	12	---> set name $tmp[1]
10	10	---> set body $tmp[2]
5	24	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
10	10	---> test -z "$name"
9	9	---> test -z "$body"
56	56	--> printf '%s\n' $body | read -lt first_word body
3	16	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
13	13	---> test $first_word = $name
51	68	--> set -l cmd_string (string escape -- "alias $argv")
17	17	---> string escape -- "alias $argv"
39	104	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
65	65	---> string join ' ' -- $first_word $body | string escape
48	56	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
8	8	---> function dotgit --wraps 'git -C /home/cjber/dotfiles' --description 'alias dotgit=git -C /home/cjber/dotfiles';  git -C /home/cjber/dotfiles $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
27	420	-> alias dotsync="dotgit pull origin master && dotgit add -A && dotgit commit && dotgit push origin master; dotdrop install"
7	7	--> set -l options 'h/help' 's/save'
11	11	--> argparse -n alias --max-args=2 $options -- $argv
2	5	--> if set -q _flag_help
        __fish_print_help alias
        return 0
    ...
3	3	---> set -q _flag_help
4	4	--> set -l name
4	4	--> set -l body
4	4	--> set -l prefix
4	4	--> set -l first_word
4	4	--> set -l wrapped_cmd
5	72	--> if not set -q argv[1]
        # Print the known aliases.
        for func in (functions -n)
            set -l output (functions $func | string match -r -- "^function .* --description 'alias (.*)'")
            if set -q output[2]
                set output (string replace -r -- '^'$func'[= ]' '' $output[2])
                echo alias $func (string escape -- $output[1])
            end
        end
        return 0
    else if not set -q argv[2]
        # Alias definition of the form "name=value".
        set -l tmp (string split -m 1 "=" -- $argv) ""
        set name $tmp[1]
        set body $tmp[2]
    else
        # Alias definition of the form "name value".
        set name $argv[1]
        set body $argv[2]
    ...
4	4	---> not set -q argv[1]
3	3	---> not set -q argv[2]
35	47	---> set -l tmp (string split -m 1 "=" -- $argv) ""
12	12	----> string split -m 1 "=" -- $argv
7	7	---> set name $tmp[1]
6	6	---> set body $tmp[2]
3	13	--> if test -z "$name"
        printf ( _ "%s: Name cannot be empty\n") alias
        return 1
    else if test -z "$body"
        printf ( _ "%s: Body cannot be empty\n") alias
        return 1
    ...
5	5	---> test -z "$name"
5	5	---> test -z "$body"
52	52	--> printf '%s\n' $body | read -lt first_word body
1	8	--> if test $first_word = $name
        if contains $name (builtin --names)
            set prefix builtin
        else
            set prefix command
        end
    ...
7	7	---> test $first_word = $name
32	43	--> set -l cmd_string (string escape -- "alias $argv")
11	11	---> string escape -- "alias $argv"
33	79	--> set wrapped_cmd (string join ' ' -- $first_word $body | string escape)
46	46	---> string join ' ' -- $first_word $body | string escape
70	77	--> echo "function $name --wraps $wrapped_cmd --description $cmd_string; $prefix $first_word $body \$argv; end" | source
7	7	---> function dotsync --wraps 'dotgit pull origin master && dotgit add -A && dotgit commit && dotgit push origin master; dotdrop install' --description 'alias dotsync=dotgit pull origin master && dotgit add -A && dotgit commit && dotgit push origin master; dotdrop install';  dotgit pull origin master && dotgit add -A && dotgit commit && dotgit push origin master; dotdrop install $argv; ...
2	6	--> if set -q _flag_save
        funcsave $name
    ...
4	4	---> set -q _flag_save
4	4	-> status --is-interactive
25418	76167	-> pyenv init - | source
55	55	--> set -gx PATH '/home/cjber/.pyenv/shims' $PATH
10	10	--> set -gx PYENV_SHELL fish
50665	50665	--> command pyenv rehash 2>/dev/null
19	19	--> function pyenv
  set command $argv[1]
  set -e argv[1]

  switch "$command"
  case activate deactivate rehash shell
    source (pyenv "sh-$command" $argv|psub)
  case '*'
    command pyenv "$command" $argv
  end
...
19	19	-> status --is-interactive
170	14060	-> pyenv virtualenv-init - | source
31	31	--> set command $argv[1]
12	12	--> set -e argv[1]
24	13796	--> switch "$command"
  case activate deactivate rehash shell
    source (pyenv "sh-$command" $argv|psub)
  case '*'
    command pyenv "$command" $argv
  ...
13772	13772	---> command pyenv "$command" $argv
38	38	--> set -gx PATH '/opt/pyenv/plugins/pyenv-virtualenv/shims' $PATH
6	6	--> set -gx PYENV_VIRTUALENV_INIT 1
7	7	--> function _pyenv_virtualenv_hook --on-event fish_prompt;
  set -l ret $status
  if [ -n "$VIRTUAL_ENV" ]
    pyenv activate --quiet; or pyenv deactivate --quiet; or true
  else
    pyenv activate --quiet; or true
  end
  return $ret
...
18	148	-> export PYTHON_CONFIGURE_OPTS="--enable-shared"
2	8	--> if not set -q argv[1]
        set -x
        return 0
    ...
6	6	---> not set -q argv[1]
11	122	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
36	50	---> set -l v (string split -m 1 "=" -- $arg)
14	14	----> string split -m 1 "=" -- $arg
24	61	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
11	11	----> count $v
6	26	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
8	8	-----> contains -- $v[1] PATH CDPATH MANPATH
4	4	-----> true
8	8	-----> set -gx $v[1] $v[2]
2	2	-> function addpath
    contains -- $argv $fish_user_paths
       or set -U fish_user_paths $fish_user_paths $argv
    echo "Updated PATH: $PATH"
...
2	2	-> function removepath
    if set -l index (contains -i $argv[1] $PATH)
        set --erase --universal fish_user_paths[$index]
        echo "Updated PATH: $PATH"
    else
        echo "$argv[1] not found in PATH: $PATH"
    end
...
4	4	-> function anaconda
    eval $HOME/.miniconda/bin/conda "shell.fish" "hook" $argv | source
...
1	1	-> function poetryreq
    for item in (cat requirements.txt); poetry add $item; end
...
2	2	-> function fish_right_prompt_loading_indicator
    echo (set_color '#aaa')' … '(set_color normal)
...
40	42	> source /usr/share/fish/functions/fish_title.fish
2	2	-> function fish_title
    # emacs is basically the only term that can't handle it.
    if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    end
...
8	620	> fish_title
4	612	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
5	5	--> not set -q INSIDE_EMACS
86	603	--> echo (status current-command) (__fish_pwd)
6	6	---> status current-command
59	511	---> __fish_pwd
44	436	----> source /usr/share/fish/functions/__fish_pwd.fish
56	392	-----> switch (uname)
    case 'CYGWIN_*'
        function __fish_pwd --description "Show current path"
            pwd | sed -e 's-^/cygdrive/\(.\)/\?-\u\1:/-'
        end
    case '*'
        function __fish_pwd --description "Show current path"
            pwd
        end
...
331	331	------> uname
5	5	------> function __fish_pwd --description "Show current path"
            pwd
        ...
16	16	----> pwd
106	112	> source /usr/share/fish/functions/fish_prompt.fish
6	6	-> function fish_prompt --description 'Write out the prompt'
    set -l last_pipestatus $pipestatus
    set -l normal (set_color normal)

    # Color the prompt differently when we're root
    set -l color_cwd $fish_color_cwd
    set -l prefix
    set -l suffix '>'
    if contains -- $USER root toor
        if set -q fish_color_cwd_root
            set color_cwd $fish_color_cwd_root
        end
        set suffix '#'
    end

    # If we're running via SSH, change the host color.
    set -l color_host $fish_color_host
    if set -q SSH_TTY
        set color_host $fish_color_host_remote
    end

    # Write pipestatus
    set -l prompt_status (__fish_print_pipestatus " [" "]" "|" (set_color $fish_color_status) (set_color --bold $fish_color_status) $last_pipestatus)

    echo -n -s (set_color $fish_color_user) "$USER" $normal @ (set_color $color_host) (prompt_hostname) $normal ' ' (set_color $color_cwd) (prompt_pwd) $normal (fish_vcs_prompt) $normal $prompt_status $suffix " "
...
10	15281	> __fish_on_interactive
84	15264	-> __fish_config_interactive
737	743	--> source /usr/share/fish/functions/__fish_config_interactive.fish
6	6	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    # usage: __init_uvar VARIABLE VALUES...
    function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    end

    #
    # If we are starting up for the first time, set various defaults.
    if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd{,_root} changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    set -l varargs --on-variable fish_key_bindings
    for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    end
    function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test
    complete -c ! --wraps not

    #
    # Only a few builtins take filenames; initialize the rest with no file completions
    #
    complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    # Similarly, enable TMUX's focus reporting when in tmux.
    # This will be handled by
    # - The keybindings (reading the sequence and triggering an event)
    # - Any listeners (like the vi-cursor)
    if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app (TODO) support this.
    if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end

    # Bump this whenever some code below needs to run once when upgrading to a new version.
    # The universal variable __fish_initialized is initialized in share/config.fish.
    set __fish_initialized 3100
...
1	12	--> if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    ...
11	11	---> test $__fish_initialized -lt 3000
0	4	--> if set -q __fish_config_interactive_done
        return
    ...
4	4	---> set -q __fish_config_interactive_done
5	5	--> set -g __fish_config_interactive_done
4	4	--> set -g __fish_active_key_bindings
1	4	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
3	3	---> not set -q fish_greeting
1	4	--> if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
3	3	---> set -q fish_private_mode
4	4	--> function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    ...
1	7	--> if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    ...
6	6	---> test $__fish_initialized -lt 3100
6	18	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    ...
3	3	---> not set -q FISH_UNIT_TESTS_RUNNING
1	9	---> if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        ...
8	8	----> not test -d $__fish_user_data_dir/generated_completions
3	36	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
4	4	---> status --is-interactive
1	29	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
22	22	----> functions -q fish_greeting
6	6	----> test -n "$fish_greeting"
7	7	--> set -l varargs --on-variable fish_key_bindings
15	46	--> for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    ...
7	7	---> set -a varargs --on-variable fish_color_$var
6	6	---> set -a varargs --on-variable fish_color_$var
6	6	---> set -a varargs --on-variable fish_color_$var
6	6	---> set -a varargs --on-variable fish_color_$var
6	6	---> set -a varargs --on-variable fish_color_$var
14	14	--> function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
1	6	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
5	5	---> test -d /etc/init.d
9	9	--> complete -c [ --wraps test
5	5	--> complete -c ! --wraps not
91	188	--> complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files
97	97	---> builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)'
6	6	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
20	11330	--> __fish_reload_key_bindings
13	22	---> __init_uvar fish_key_bindings fish_default_key_bindings
2	9	----> if not set --query $argv[1]
            set --universal $argv
        ...
7	7	-----> not set --query $argv[1]
2	13	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
11	11	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
1	8	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
7	7	----> not functions -q "$fish_key_bindings"
7	7	---> set -g __fish_active_key_bindings "$fish_key_bindings"
12	124	---> set -g fish_bind_mode default
11	112	----> fish_vi_cursor_handle VARIABLE SET fish_bind_mode
6	6	-----> set -l varname fish_cursor_$fish_bind_mode
0	5	-----> if not set -q $varname
                set varname fish_cursor_unknown
              ...
5	5	------> not set -q $varname
12	90	-----> __fish_cursor_xterm $$varname
6	6	------> set -l shape $argv[1]
4	8	------> switch "$shape"
        case block
            set shape 2
        case underscore
            set shape 4
        case line
            set shape 6
    ...
4	4	-------> set shape 2
2	54	------> if contains blink $argv
        set shape (math $shape - 1)
    ...
7	7	-------> contains blink $argv
29	45	-------> set shape (math $shape - 1)
16	16	--------> math $shape - 1
10	10	------> echo -en "\e[$shape q"
2	11088	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
6	6	----> test "$fish_key_bindings" = fish_default_key_bindings
195	11080	----> $fish_key_bindings 2>/dev/null
2	12	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
6	6	------> contains -- -h $argv
4	4	------> contains -- --help $argv
5	5	-----> set -l rebind true
3	67	-----> if test "$argv[1]" = "--no-erase"
        set rebind false
        set -e argv[1]
    else
        bind --erase --all --preset # clear earlier bindings, if any
    ...
6	6	------> test "$argv[1]" = "--no-erase"
58	58	------> bind --erase --all --preset
1	8	-----> if test "$fish_key_bindings" != "fish_vi_key_bindings"
        and test "$rebind" = "true"
        # Allow the user to set the variable universally.
        set -q fish_key_bindings
        or set -g fish_key_bindings
        # This triggers the handler, which calls us again and ensures the user_key_bindings
        # are executed.
        set fish_key_bindings fish_vi_key_bindings
        return
    ...
7	7	------> test "$fish_key_bindings" != "fish_vi_key_bindings"
5	5	-----> set -l init_mode insert
6	6	-----> set -l eol_keys \$ g\$
6	6	-----> set -l bol_keys \^ 0 g\^
3	12	-----> if contains -- $argv[1] insert default visual
        set init_mode $argv[1]
    else if set -q argv[1]
        # We should still go on so the bindings still get set.
        echo "Unknown argument $argv" >&2
    ...
6	6	------> contains -- $argv[1] insert default visual
3	3	------> set -q argv[1]
15	4310	-----> for mode in insert default visual
        __fish_shared_key_bindings -s -M $mode
    ...
76	964	------> __fish_shared_key_bindings -s -M $mode
1	14	-------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
7	7	--------> contains -- -h $argv
6	6	--------> contains -- --help $argv
8	8	-------> bind --preset $argv \cy yank
7	7	-------> bind --preset $argv \ey yank-pop
9	9	-------> bind --preset $argv -k right forward-char
7	7	-------> bind --preset $argv -k left backward-char
7	7	-------> bind --preset $argv \e\[C forward-char
7	7	-------> bind --preset $argv \e\[D backward-char
7	7	-------> bind --preset $argv \eOC forward-char
7	7	-------> bind --preset $argv \eOD backward-char
7	7	-------> bind --preset $argv -k ppage beginning-of-history
7	7	-------> bind --preset $argv -k npage end-of-history
7	7	-------> bind --preset $argv \cx fish_clipboard_copy
7	7	-------> bind --preset $argv \cv fish_clipboard_paste
7	7	-------> bind --preset $argv \e cancel
7	7	-------> bind --preset $argv \t complete
7	7	-------> bind --preset $argv \cs pager-toggle-search
7	7	-------> bind --preset $argv --key btab complete-and-search
7	7	-------> bind --preset $argv \e\n "commandline -i \n"
7	7	-------> bind --preset $argv \e\r "commandline -i \n"
7	7	-------> bind --preset $argv -k down down-or-search
8	8	-------> bind --preset $argv -k up up-or-search
6	6	-------> bind --preset $argv \e\[A up-or-search
6	6	-------> bind --preset $argv \e\[B down-or-search
6	6	-------> bind --preset $argv \eOA up-or-search
6	6	-------> bind --preset $argv \eOB down-or-search
7	7	-------> bind --preset $argv -k sright forward-bigword
7	7	-------> bind --preset $argv -k sleft backward-bigword
7	7	-------> bind --preset $argv \e\eOC nextd-or-forward-word
7	7	-------> bind --preset $argv \e\eOD prevd-or-backward-word
7	7	-------> bind --preset $argv \e\e\[C nextd-or-forward-word
7	7	-------> bind --preset $argv \e\e\[D prevd-or-backward-word
6	6	-------> bind --preset $argv \eO3C nextd-or-forward-word
7	7	-------> bind --preset $argv \eO3D prevd-or-backward-word
7	7	-------> bind --preset $argv \e\[3C nextd-or-forward-word
6	6	-------> bind --preset $argv \e\[3D prevd-or-backward-word
7	7	-------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
7	7	-------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
7	7	-------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
6	6	-------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
7	7	-------> bind --preset $argv \e\eOA history-token-search-backward
7	7	-------> bind --preset $argv \e\eOB history-token-search-forward
7	7	-------> bind --preset $argv \e\e\[A history-token-search-backward
7	7	-------> bind --preset $argv \e\e\[B history-token-search-forward
7	7	-------> bind --preset $argv \eO3A history-token-search-backward
7	7	-------> bind --preset $argv \eO3B history-token-search-forward
7	7	-------> bind --preset $argv \e\[3A history-token-search-backward
7	7	-------> bind --preset $argv \e\[3B history-token-search-forward
7	7	-------> bind --preset $argv \e\[1\;3A history-token-search-backward
7	7	-------> bind --preset $argv \e\[1\;3B history-token-search-forward
7	7	-------> bind --preset $argv \e\[1\;9A history-token-search-backward
7	7	-------> bind --preset $argv \e\[1\;9B history-token-search-forward
7	7	-------> bind --preset $argv \e. history-token-search-backward
7	7	-------> bind --preset $argv \el __fish_list_current_token
7	7	-------> bind --preset $argv \ew __fish_whatis_current_token
8	8	-------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
6	6	-------> bind --preset $argv \cc __fish_cancel_commandline
7	7	-------> bind --preset $argv \cu backward-kill-line
6	6	-------> bind --preset $argv \cw backward-kill-path-component
6	6	-------> bind --preset $argv \e\[F end-of-line
7	7	-------> bind --preset $argv \e\[H beginning-of-line
9	9	-------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
6	6	-------> bind --preset $argv \cd delete-or-exit
6	6	-------> bind --preset $argv \es __fish_prepend_sudo
8	8	-------> bind --preset $argv -k f1 __fish_man_page
7	7	-------> bind --preset $argv \eh __fish_man_page
8	8	-------> bind --preset $argv \ep '__fish_paginate'
7	7	-------> bind --preset $argv \e\# __fish_toggle_comment_commandline
7	7	-------> bind --preset $argv \ee edit_command_buffer
6	6	-------> bind --preset $argv \ev edit_command_buffer
56	180	-------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
78	78	--------> bind --list-modes | string match -v paste
12	12	--------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
7	7	--------> bind --preset -M $mode \e\[O false
7	7	--------> bind --preset -M $mode \e\[\?1004h false
7	7	--------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
6	6	--------> bind --preset -M $mode \e\[O false
7	7	--------> bind --preset -M $mode \e\[\?1004h false
59	182	-------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
82	82	--------> bind --list-modes | string match -v paste
31	31	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
10	10	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
8	8	-------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
6	6	-------> bind --preset -M paste "" self-insert
7	7	-------> bind --preset -M paste \r "commandline -i \n"
7	7	-------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
7	7	-------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
5	5	-------> bind --preset -M paste " " self-insert-notfirst
98	1343	------> __fish_shared_key_bindings -s -M $mode
1	15	-------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
8	8	--------> contains -- -h $argv
6	6	--------> contains -- --help $argv
8	8	-------> bind --preset $argv \cy yank
7	7	-------> bind --preset $argv \ey yank-pop
9	9	-------> bind --preset $argv -k right forward-char
8	8	-------> bind --preset $argv -k left backward-char
7	7	-------> bind --preset $argv \e\[C forward-char
7	7	-------> bind --preset $argv \e\[D backward-char
7	7	-------> bind --preset $argv \eOC forward-char
7	7	-------> bind --preset $argv \eOD backward-char
8	8	-------> bind --preset $argv -k ppage beginning-of-history
8	8	-------> bind --preset $argv -k npage end-of-history
7	7	-------> bind --preset $argv \cx fish_clipboard_copy
7	7	-------> bind --preset $argv \cv fish_clipboard_paste
7	7	-------> bind --preset $argv \e cancel
7	7	-------> bind --preset $argv \t complete
7	7	-------> bind --preset $argv \cs pager-toggle-search
8	8	-------> bind --preset $argv --key btab complete-and-search
8	8	-------> bind --preset $argv \e\n "commandline -i \n"
13	13	-------> bind --preset $argv \e\r "commandline -i \n"
8	8	-------> bind --preset $argv -k down down-or-search
9	9	-------> bind --preset $argv -k up up-or-search
7	7	-------> bind --preset $argv \e\[A up-or-search
7	7	-------> bind --preset $argv \e\[B down-or-search
7	7	-------> bind --preset $argv \eOA up-or-search
6	6	-------> bind --preset $argv \eOB down-or-search
9	9	-------> bind --preset $argv -k sright forward-bigword
8	8	-------> bind --preset $argv -k sleft backward-bigword
8	8	-------> bind --preset $argv \e\eOC nextd-or-forward-word
8	8	-------> bind --preset $argv \e\eOD prevd-or-backward-word
8	8	-------> bind --preset $argv \e\e\[C nextd-or-forward-word
7	7	-------> bind --preset $argv \e\e\[D prevd-or-backward-word
7	7	-------> bind --preset $argv \eO3C nextd-or-forward-word
8	8	-------> bind --preset $argv \eO3D prevd-or-backward-word
8	8	-------> bind --preset $argv \e\[3C nextd-or-forward-word
8	8	-------> bind --preset $argv \e\[3D prevd-or-backward-word
8	8	-------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
7	7	-------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
8	8	-------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
8	8	-------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
8	8	-------> bind --preset $argv \e\eOA history-token-search-backward
7	7	-------> bind --preset $argv \e\eOB history-token-search-forward
7	7	-------> bind --preset $argv \e\e\[A history-token-search-backward
7	7	-------> bind --preset $argv \e\e\[B history-token-search-forward
7	7	-------> bind --preset $argv \eO3A history-token-search-backward
8	8	-------> bind --preset $argv \eO3B history-token-search-forward
8	8	-------> bind --preset $argv \e\[3A history-token-search-backward
11	11	-------> bind --preset $argv \e\[3B history-token-search-forward
20	20	-------> bind --preset $argv \e\[1\;3A history-token-search-backward
12	12	-------> bind --preset $argv \e\[1\;3B history-token-search-forward
10	10	-------> bind --preset $argv \e\[1\;9A history-token-search-backward
12	12	-------> bind --preset $argv \e\[1\;9B history-token-search-forward
11	11	-------> bind --preset $argv \e. history-token-search-backward
9	9	-------> bind --preset $argv \el __fish_list_current_token
8	8	-------> bind --preset $argv \ew __fish_whatis_current_token
9	9	-------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
8	8	-------> bind --preset $argv \cc __fish_cancel_commandline
8	8	-------> bind --preset $argv \cu backward-kill-line
10	10	-------> bind --preset $argv \cw backward-kill-path-component
12	12	-------> bind --preset $argv \e\[F end-of-line
10	10	-------> bind --preset $argv \e\[H beginning-of-line
15	15	-------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
7	7	-------> bind --preset $argv \cd delete-or-exit
9	9	-------> bind --preset $argv \es __fish_prepend_sudo
8	8	-------> bind --preset $argv -k f1 __fish_man_page
9	9	-------> bind --preset $argv \eh __fish_man_page
8	8	-------> bind --preset $argv \ep '__fish_paginate'
8	8	-------> bind --preset $argv \e\# __fish_toggle_comment_commandline
8	8	-------> bind --preset $argv \ee edit_command_buffer
7	7	-------> bind --preset $argv \ev edit_command_buffer
79	318	-------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
155	155	--------> bind --list-modes | string match -v paste
28	28	--------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
13	13	--------> bind --preset -M $mode \e\[O false
11	11	--------> bind --preset -M $mode \e\[\?1004h false
12	12	--------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
10	10	--------> bind --preset -M $mode \e\[O false
10	10	--------> bind --preset -M $mode \e\[\?1004h false
66	275	-------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
176	176	--------> bind --list-modes | string match -v paste
20	20	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
13	13	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
11	11	-------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
10	10	-------> bind --preset -M paste "" self-insert
11	11	-------> bind --preset -M paste \r "commandline -i \n"
11	11	-------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
10	10	-------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
9	9	-------> bind --preset -M paste " " self-insert-notfirst
135	1988	------> __fish_shared_key_bindings -s -M $mode
2	25	-------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
13	13	--------> contains -- -h $argv
10	10	--------> contains -- --help $argv
14	14	-------> bind --preset $argv \cy yank
14	14	-------> bind --preset $argv \ey yank-pop
17	17	-------> bind --preset $argv -k right forward-char
15	15	-------> bind --preset $argv -k left backward-char
14	14	-------> bind --preset $argv \e\[C forward-char
13	13	-------> bind --preset $argv \e\[D backward-char
12	12	-------> bind --preset $argv \eOC forward-char
11	11	-------> bind --preset $argv \eOD backward-char
17	17	-------> bind --preset $argv -k ppage beginning-of-history
15	15	-------> bind --preset $argv -k npage end-of-history
13	13	-------> bind --preset $argv \cx fish_clipboard_copy
11	11	-------> bind --preset $argv \cv fish_clipboard_paste
12	12	-------> bind --preset $argv \e cancel
12	12	-------> bind --preset $argv \t complete
12	12	-------> bind --preset $argv \cs pager-toggle-search
14	14	-------> bind --preset $argv --key btab complete-and-search
14	14	-------> bind --preset $argv \e\n "commandline -i \n"
14	14	-------> bind --preset $argv \e\r "commandline -i \n"
13	13	-------> bind --preset $argv -k down down-or-search
15	15	-------> bind --preset $argv -k up up-or-search
14	14	-------> bind --preset $argv \e\[A up-or-search
14	14	-------> bind --preset $argv \e\[B down-or-search
12	12	-------> bind --preset $argv \eOA up-or-search
11	11	-------> bind --preset $argv \eOB down-or-search
17	17	-------> bind --preset $argv -k sright forward-bigword
15	15	-------> bind --preset $argv -k sleft backward-bigword
14	14	-------> bind --preset $argv \e\eOC nextd-or-forward-word
14	14	-------> bind --preset $argv \e\eOD prevd-or-backward-word
13	13	-------> bind --preset $argv \e\e\[C nextd-or-forward-word
14	14	-------> bind --preset $argv \e\e\[D prevd-or-backward-word
13	13	-------> bind --preset $argv \eO3C nextd-or-forward-word
14	14	-------> bind --preset $argv \eO3D prevd-or-backward-word
14	14	-------> bind --preset $argv \e\[3C nextd-or-forward-word
13	13	-------> bind --preset $argv \e\[3D prevd-or-backward-word
15	15	-------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
14	14	-------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
14	14	-------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
14	14	-------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
14	14	-------> bind --preset $argv \e\eOA history-token-search-backward
14	14	-------> bind --preset $argv \e\eOB history-token-search-forward
13	13	-------> bind --preset $argv \e\e\[A history-token-search-backward
14	14	-------> bind --preset $argv \e\e\[B history-token-search-forward
13	13	-------> bind --preset $argv \eO3A history-token-search-backward
14	14	-------> bind --preset $argv \eO3B history-token-search-forward
14	14	-------> bind --preset $argv \e\[3A history-token-search-backward
13	13	-------> bind --preset $argv \e\[3B history-token-search-forward
14	14	-------> bind --preset $argv \e\[1\;3A history-token-search-backward
14	14	-------> bind --preset $argv \e\[1\;3B history-token-search-forward
14	14	-------> bind --preset $argv \e\[1\;9A history-token-search-backward
14	14	-------> bind --preset $argv \e\[1\;9B history-token-search-forward
13	13	-------> bind --preset $argv \e. history-token-search-backward
12	12	-------> bind --preset $argv \el __fish_list_current_token
13	13	-------> bind --preset $argv \ew __fish_whatis_current_token
15	15	-------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
12	12	-------> bind --preset $argv \cc __fish_cancel_commandline
12	12	-------> bind --preset $argv \cu backward-kill-line
12	12	-------> bind --preset $argv \cw backward-kill-path-component
14	14	-------> bind --preset $argv \e\[F end-of-line
13	13	-------> bind --preset $argv \e\[H beginning-of-line
16	16	-------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
12	12	-------> bind --preset $argv \cd delete-or-exit
13	13	-------> bind --preset $argv \es __fish_prepend_sudo
14	14	-------> bind --preset $argv -k f1 __fish_man_page
12	12	-------> bind --preset $argv \eh __fish_man_page
14	14	-------> bind --preset $argv \ep '__fish_paginate'
13	13	-------> bind --preset $argv \e\# __fish_toggle_comment_commandline
12	12	-------> bind --preset $argv \ee edit_command_buffer
13	13	-------> bind --preset $argv \ev edit_command_buffer
105	483	-------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
228	228	--------> bind --list-modes | string match -v paste
32	32	--------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
14	14	--------> bind --preset -M $mode \e\[O false
12	12	--------> bind --preset -M $mode \e\[\?1004h false
14	14	--------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
12	12	--------> bind --preset -M $mode \e\[O false
12	12	--------> bind --preset -M $mode \e\[\?1004h false
20	20	--------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
15	15	--------> bind --preset -M $mode \e\[O false
19	19	--------> bind --preset -M $mode \e\[\?1004h false
70	353	-------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
231	231	--------> bind --list-modes | string match -v paste
21	21	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
14	14	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
17	17	--------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
11	11	-------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
12	12	-------> bind --preset -M paste "" self-insert
12	12	-------> bind --preset -M paste \r "commandline -i \n"
13	13	-------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
12	12	-------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
11	11	-------> bind --preset -M paste " " self-insert-notfirst
13	13	-----> bind -s --preset -M insert \r execute
12	12	-----> bind -s --preset -M insert \n execute
12	12	-----> bind -s --preset -M insert "" self-insert
13	13	-----> bind -s --preset -M insert " " self-insert expand-abbr
14	14	-----> bind -s --preset -M insert \e "if commandline -P; commandline -f cancel; else; set fish_bind_mode default; commandline -f backward-char repaint-mode; end"
10	10	-----> bind -s --preset :q exit
11	11	-----> bind -s --preset -m insert \cc __fish_cancel_commandline
11	11	-----> bind -s --preset -M default h backward-char
10	10	-----> bind -s --preset -M default l forward-char
13	13	-----> bind -s --preset -m insert \n execute
11	11	-----> bind -s --preset -m insert \r execute
11	11	-----> bind -s --preset -m insert i repaint-mode
22	22	-----> bind -s --preset -m insert I beginning-of-line repaint-mode
12	12	-----> bind -s --preset -m insert a forward-char repaint-mode
11	11	-----> bind -s --preset -m insert A end-of-line repaint-mode
11	11	-----> bind -s --preset -m visual v begin-selection repaint-mode
12	12	-----> bind -s --preset gg beginning-of-buffer
11	11	-----> bind -s --preset G end-of-buffer
23	49	-----> for key in $eol_keys
        bind -s --preset $key end-of-line
    ...
13	13	------> bind -s --preset $key end-of-line
13	13	------> bind -s --preset $key end-of-line
16	54	-----> for key in $bol_keys
        bind -s --preset $key beginning-of-line
    ...
13	13	------> bind -s --preset $key beginning-of-line
12	12	------> bind -s --preset $key beginning-of-line
13	13	------> bind -s --preset $key beginning-of-line
10	10	-----> bind -s --preset u history-search-backward
11	11	-----> bind -s --preset \cr history-search-forward
10	10	-----> bind -s --preset [ history-token-search-backward
10	10	-----> bind -s --preset ] history-token-search-forward
10	10	-----> bind -s --preset k up-or-search
10	10	-----> bind -s --preset j down-or-search
10	10	-----> bind -s --preset b backward-word
10	10	-----> bind -s --preset B backward-bigword
11	11	-----> bind -s --preset ge backward-word
11	11	-----> bind -s --preset gE backward-bigword
11	11	-----> bind -s --preset w forward-word forward-char
11	11	-----> bind -s --preset W forward-bigword forward-char
11	11	-----> bind -s --preset e forward-char forward-word backward-char
11	11	-----> bind -s --preset E forward-bigword backward-char
29	29	-----> bind -s --preset -M insert -k home beginning-of-line 2>/dev/null
20	20	-----> bind -s --preset -M default -k home beginning-of-line 2>/dev/null
18	18	-----> bind -s --preset -M insert -k end end-of-line 2>/dev/null
18	18	-----> bind -s --preset -M default -k end end-of-line 2>/dev/null
13	13	-----> bind -s --preset -M default x delete-char forward-char backward-char
11	11	-----> bind -s --preset -M default X backward-delete-char
16	16	-----> bind -s --preset -M insert -k dc delete-char forward-char backward-char
16	16	-----> bind -s --preset -M default -k dc delete-char forward-char backward-char
12	12	-----> bind -s --preset -M insert -k backspace backward-delete-char
12	12	-----> bind -s --preset -M default -k backspace backward-char
13	13	-----> bind -s --preset -M insert \ch backward-delete-char
13	13	-----> bind -s --preset -M default \ch backward-char
11	11	-----> bind -s --preset -M insert \x7f backward-delete-char
10	10	-----> bind -s --preset -M default \x7f backward-char
16	16	-----> bind -s --preset -M insert \e\[3\;2~ backward-delete-char
15	15	-----> bind -s --preset -M default \e\[3\;2~ backward-delete-char
11	11	-----> bind -s --preset dd kill-whole-line
10	10	-----> bind -s --preset D kill-line
13	13	-----> bind -s --preset d\$ kill-line
12	12	-----> bind -s --preset d\^ backward-kill-line
11	11	-----> bind -s --preset d0 backward-kill-line
11	11	-----> bind -s --preset dw kill-word
11	11	-----> bind -s --preset dW kill-bigword
14	14	-----> bind -s --preset diw forward-char forward-char backward-word kill-word
14	14	-----> bind -s --preset diW forward-char forward-char backward-bigword kill-bigword
13	13	-----> bind -s --preset daw forward-char forward-char backward-word kill-word
14	14	-----> bind -s --preset daW forward-char forward-char backward-bigword kill-bigword
11	11	-----> bind -s --preset de kill-word
11	11	-----> bind -s --preset dE kill-bigword
12	12	-----> bind -s --preset db backward-kill-word
11	11	-----> bind -s --preset dB backward-kill-bigword
11	11	-----> bind -s --preset dge backward-kill-word
12	12	-----> bind -s --preset dgE backward-kill-bigword
13	13	-----> bind -s --preset df begin-selection forward-jump kill-selection end-selection
14	14	-----> bind -s --preset dt begin-selection forward-jump backward-char kill-selection end-selection
13	13	-----> bind -s --preset dF begin-selection backward-jump kill-selection end-selection
13	13	-----> bind -s --preset dT begin-selection backward-jump forward-char kill-selection end-selection
12	12	-----> bind -s --preset -m insert s delete-char repaint-mode
12	12	-----> bind -s --preset -m insert S kill-whole-line repaint-mode
12	12	-----> bind -s --preset -m insert cc kill-whole-line repaint-mode
12	12	-----> bind -s --preset -m insert C kill-line repaint-mode
14	14	-----> bind -s --preset -m insert c\$ kill-line repaint-mode
14	14	-----> bind -s --preset -m insert c\^ backward-kill-line repaint-mode
13	13	-----> bind -s --preset -m insert cw kill-word repaint-mode
13	13	-----> bind -s --preset -m insert cW kill-bigword repaint-mode
15	15	-----> bind -s --preset -m insert ciw forward-char forward-char backward-word kill-word repaint-mode
16	16	-----> bind -s --preset -m insert ciW forward-char forward-char backward-bigword kill-bigword repaint-mode
15	15	-----> bind -s --preset -m insert caw forward-char forward-char backward-word kill-word repaint-mode
15	15	-----> bind -s --preset -m insert caW forward-char forward-char backward-bigword kill-bigword repaint-mode
13	13	-----> bind -s --preset -m insert ce kill-word repaint-mode
13	13	-----> bind -s --preset -m insert cE kill-bigword repaint-mode
13	13	-----> bind -s --preset -m insert cb backward-kill-word repaint-mode
14	14	-----> bind -s --preset -m insert cB backward-kill-bigword repaint-mode
13	13	-----> bind -s --preset -m insert cge backward-kill-word repaint-mode
14	14	-----> bind -s --preset -m insert cgE backward-kill-bigword repaint-mode
12	12	-----> bind -s --preset '~' capitalize-word
12	12	-----> bind -s --preset gu downcase-word
11	11	-----> bind -s --preset gU upcase-word
11	11	-----> bind -s --preset J end-of-line delete-char
13	13	-----> bind -s --preset K 'man (commandline -t) 2>/dev/null; or echo -n \a'
13	13	-----> bind -s --preset yy kill-whole-line yank
11	11	-----> bind -s --preset Y kill-whole-line yank
14	14	-----> bind -s --preset y\$ kill-line yank
13	13	-----> bind -s --preset y\^ backward-kill-line yank
12	12	-----> bind -s --preset yw kill-word yank
13	13	-----> bind -s --preset yW kill-bigword yank
15	15	-----> bind -s --preset yiw forward-char forward-char backward-word kill-word yank
15	15	-----> bind -s --preset yiW forward-char forward-char backward-bigword kill-bigword yank
15	15	-----> bind -s --preset yaw forward-char forward-char backward-word kill-word yank
15	15	-----> bind -s --preset yaW forward-char forward-char backward-bigword kill-bigword yank
13	13	-----> bind -s --preset ye kill-word yank
12	12	-----> bind -s --preset yE kill-bigword yank
13	13	-----> bind -s --preset yb backward-kill-word yank
12	12	-----> bind -s --preset yB backward-kill-bigword yank
13	13	-----> bind -s --preset yge backward-kill-word yank
13	13	-----> bind -s --preset ygE backward-kill-bigword yank
11	11	-----> bind -s --preset f forward-jump
11	11	-----> bind -s --preset F backward-jump
11	11	-----> bind -s --preset t forward-jump-till
10	10	-----> bind -s --preset T backward-jump-till
12	12	-----> bind -s --preset ';' repeat-jump
11	11	-----> bind -s --preset , repeat-jump-reverse
11	11	-----> bind -s --preset p yank
11	11	-----> bind -s --preset P backward-char yank
12	12	-----> bind -s --preset gp yank-pop
16	16	-----> bind -s --preset '"*p' "commandline -i ( xsel -p; echo )[1]"
17	17	-----> bind -s --preset '"*P' backward-char "commandline -i ( xsel -p; echo )[1]"
12	12	-----> bind -s --preset -m replace_one r repaint-mode
14	14	-----> bind -s --preset -M replace_one -m default '' delete-char self-insert backward-char repaint-mode
17	17	-----> bind -s --preset -M replace_one -m default \r 'commandline -f delete-char; commandline -i \n; commandline -f backward-char; commandline -f repaint-mode'
15	15	-----> bind -s --preset -M replace_one -m default \e cancel repaint-mode
12	12	-----> bind -s --preset -m replace R repaint-mode
12	12	-----> bind -s --preset -M replace '' delete-char self-insert
14	14	-----> bind -s --preset -M replace -m insert \r execute repaint-mode
14	14	-----> bind -s --preset -M replace -m default \e cancel repaint-mode
13	13	-----> bind -s --preset -M replace -k backspace backward-char
11	11	-----> bind -s --preset -M visual h backward-char
12	12	-----> bind -s --preset -M visual l forward-char
11	11	-----> bind -s --preset -M visual k up-line
12	12	-----> bind -s --preset -M visual j down-line
11	11	-----> bind -s --preset -M visual b backward-word
12	12	-----> bind -s --preset -M visual B backward-bigword
13	13	-----> bind -s --preset -M visual ge backward-word
13	13	-----> bind -s --preset -M visual gE backward-bigword
11	11	-----> bind -s --preset -M visual w forward-word
12	12	-----> bind -s --preset -M visual W forward-bigword
12	12	-----> bind -s --preset -M visual e forward-word
12	12	-----> bind -s --preset -M visual E forward-bigword
13	13	-----> bind -s --preset -M visual o swap-selection-start-stop repaint-mode
12	12	-----> bind -s --preset -M visual f forward-jump
12	12	-----> bind -s --preset -M visual t forward-jump-till
11	11	-----> bind -s --preset -M visual F backward-jump
12	12	-----> bind -s --preset -M visual T backward-jump-till
30	60	-----> for key in $eol_keys
        bind -s --preset -M visual $key end-of-line
    ...
14	14	------> bind -s --preset -M visual $key end-of-line
16	16	------> bind -s --preset -M visual $key end-of-line
15	59	-----> for key in $bol_keys
        bind -s --preset -M visual $key beginning-of-line
    ...
14	14	------> bind -s --preset -M visual $key beginning-of-line
14	14	------> bind -s --preset -M visual $key beginning-of-line
16	16	------> bind -s --preset -M visual $key beginning-of-line
15	15	-----> bind -s --preset -M visual -m insert c kill-selection end-selection repaint-mode
15	15	-----> bind -s --preset -M visual -m default d kill-selection end-selection repaint-mode
15	15	-----> bind -s --preset -M visual -m default x kill-selection end-selection repaint-mode
15	15	-----> bind -s --preset -M visual -m default X kill-whole-line end-selection repaint-mode
15	15	-----> bind -s --preset -M visual -m default y kill-selection yank end-selection repaint-mode
19	19	-----> bind -s --preset -M visual -m default '"*y' "commandline -s | xsel -p; commandline -f end-selection repaint-mode"
14	14	-----> bind -s --preset -M visual -m default \cc end-selection repaint-mode
12	12	-----> bind -s --preset -M visual -m default \e end-selection repaint-mode
14	14	-----> bind -s --preset -M default \# __fish_toggle_comment_commandline
14	14	-----> bind -s --preset -M visual \# __fish_toggle_comment_commandline
13	13	-----> bind -s --preset -M replace \# __fish_toggle_comment_commandline
48	3970	-----> fish_vi_cursor
2	10	------> if not status is-interactive
        return
    ...
8	8	-------> not status is-interactive
2	10	------> if set -q FISH_UNIT_TESTS_RUNNING
        return
    ...
8	8	-------> set -q FISH_UNIT_TESTS_RUNNING
1	8	------> if set -q INSIDE_EMACS
        return
    ...
7	7	-------> set -q INSIDE_EMACS
2	8	------> if set -q VTE_VERSION
        and test "$VTE_VERSION" -lt 4000 2>/dev/null
        return
    ...
6	6	-------> set -q VTE_VERSION
2	8	------> if set -q XTERM_VERSION
        and not test (string replace -r "XTerm\((\d+)\)" '$1' -- "$XTERM_VERSION") -ge 280 2>/dev/null
        return
    ...
6	6	-------> set -q XTERM_VERSION
6	74	------> if not set -q KONSOLE_PROFILE_NAME
        and not set -q ITERM_PROFILE
        and not set -q VTE_VERSION # which version is already checked above
        and not set -q XTERM_VERSION
        and not string match -rq '^st(-.*)$' -- $TERM
        and not string match -q 'xterm-kitty*' -- $TERM
        and not string match -q 'rxvt*' -- $TERM
        return
    ...
7	7	-------> not set -q KONSOLE_PROFILE_NAME
5	5	-------> not set -q ITERM_PROFILE
6	6	-------> not set -q VTE_VERSION
6	6	-------> not set -q XTERM_VERSION
31	31	-------> not string match -rq '^st(-.*)$' -- $TERM
13	13	-------> not string match -q 'xterm-kitty*' -- $TERM
5	27	------> if contains -- $argv[1] --force-iterm
        set -e argv[1]
    else if set -q ITERM_PROFILE
        return
    ...
14	14	-------> contains -- $argv[1] --force-iterm
8	8	-------> set -q ITERM_PROFILE
13	13	------> set -l terminal $argv[1]
9	9	------> set -q terminal[1]
11	11	------> set terminal auto
11	11	------> set -l function
18	56	------> switch "$terminal"
        case auto
            # TODO: Konsole as of 18.08 knows the xterm sequences,
            # but there's still bugs with it (as of konsole 19.04.0).
            #
            # If it is fixed, we'd have to read $KONSOLE_VERSION for a while,
            # though that was only introduced in 18.08 as well.
            if set -q KONSOLE_PROFILE_NAME
                set function __fish_cursor_konsole
            else if set -q ITERM_PROFILE
                set function __fish_cursor_1337
            else
                set function __fish_cursor_xterm
            end
        case konsole
            set function __fish_cursor_konsole
        case xterm
            set function __fish_cursor_xterm
    ...
6	38	-------> if set -q KONSOLE_PROFILE_NAME
                set function __fish_cursor_konsole
            else if set -q ITERM_PROFILE
                set function __fish_cursor_1337
            else
                set function __fish_cursor_xterm
            ...
12	12	--------> set -q KONSOLE_PROFILE_NAME
8	8	--------> set -q ITERM_PROFILE
12	12	--------> set function __fish_cursor_xterm
11	11	------> set -l tmux_prefix
9	9	------> set -l tmux_postfix
2	10	------> if set -q TMUX
        set tmux_prefix echo -ne "'\ePtmux;\e'"
        set tmux_postfix echo -ne "'\e\\\\'"
    ...
8	8	-------> set -q TMUX
8	8	------> set -q fish_cursor_unknown
3417	3440	------> echo "
          function fish_vi_cursor_handle --on-variable fish_bind_mode --on-event fish_postexec --on-event fish_focus_in
              set -l varname fish_cursor_\$fish_bind_mode
              if not set -q \$varname
                set varname fish_cursor_unknown
              end
              $tmux_prefix
              $function \$\$varname
              $tmux_postfix
          end
         " | source
23	23	-------> function fish_vi_cursor_handle --on-variable fish_bind_mode --on-event fish_postexec --on-event fish_focus_in
              set -l varname fish_cursor_$fish_bind_mode
              if not set -q $varname
                set varname fish_cursor_unknown
              end
              
              __fish_cursor_xterm $$varname
              
          ...
188	199	------> echo "
          function fish_vi_cursor_handle_preexec --on-event fish_preexec
              set -l varname fish_cursor_default
              if not set -q \$varname
                set varname fish_cursor_unknown
              end
              $tmux_prefix
              $function \$\$varname
              $tmux_postfix
          end
         " | source
11	11	-------> function fish_vi_cursor_handle_preexec --on-event fish_preexec
              set -l varname fish_cursor_default
              if not set -q $varname
                set varname fish_cursor_unknown
              end
              
              __fish_cursor_xterm $$varname
              
          ...
36	264	-----> set fish_bind_mode $init_mode
21	228	------> fish_vi_cursor_handle VARIABLE SET fish_bind_mode
16	16	-------> set -l varname fish_cursor_$fish_bind_mode
2	12	-------> if not set -q $varname
                set varname fish_cursor_unknown
              ...
10	10	--------> not set -q $varname
27	179	-------> __fish_cursor_xterm $$varname
13	13	--------> set -l shape $argv[1]
10	19	--------> switch "$shape"
        case block
            set shape 2
        case underscore
            set shape 4
        case line
            set shape 6
    ...
9	9	---------> set shape 6
5	101	--------> if contains blink $argv
        set shape (math $shape - 1)
    ...
13	13	---------> contains blink $argv
53	83	---------> set shape (math $shape - 1)
30	30	----------> math $shape - 1
19	19	--------> echo -en "\e[$shape q"
3	48	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
45	45	----> functions --query fish_user_key_bindings >/dev/null
6	60	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
9	9	---> not set -q FISH_UNIT_TESTS_RUNNING
7	7	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
7	7	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
15	31	---> __fish_enable_bracketed_paste
16	16	----> printf "\e[?2004h"
2	9	--> if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    ...
7	7	---> set -q TMUX
12	12	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
3	112	--> if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
76	109	---> test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
33	33	----> string match -r '\d+' 0"$TERM_PROGRAM_VERSION"
12	2526	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
107	1344	---> not type -q __fish_command_not_found_handler
571	580	----> source /usr/share/fish/functions/type.fish
9	9	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
9	9	----> set -q argv[1]
22	22	----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
41	41	----> argparse -n type -x t,p,P $options -- $argv
2	9	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
7	7	-----> set -q _flag_help
9	9	----> set -l res 1
9	9	----> set -l mode normal
8	8	----> set -l multi no
8	8	----> set -l selection all
8	8	----> set -l short no
5	19	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
6	6	-----> set -q _flag_quiet
8	8	-----> set mode quiet
6	6	----> set -q _flag_all
6	6	----> set -q _flag_short
6	6	----> set -q _flag_no_functions
25	489	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
8	8	-----> set -l found 0
6	214	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
11	11	------> test $selection != files
1	37	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
36	36	-------> functions -q -- $i
2	160	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
123	158	-------> contains -- $i (builtin -n)
35	35	--------> builtin -n
10	10	-----> set -l paths
5	195	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
10	10	------> test $multi != yes
83	180	------> set paths (command -s -- $i)
97	97	-------> command -s -- $i
12	12	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
2	25	-----> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
13	13	------> test $found = 0
10	10	------> test $mode != quiet
8	8	----> return $res
9	9	---> set -l os
3	343	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
15	15	----> test -r /etc/os-release
98	325	----> set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
227	227	-----> string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " "
8	818	---> if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
16	16	----> contains -- suse $os
5	5	----> contains -- sles $os
12	12	----> test -f /usr/libexec/pk-command-not-found
5	5	----> test -f /usr/lib/command-not-found
7	7	----> test -f /run/current-system/sw/bin/command-not-found
33	414	----> type -q command-not-found
6	6	-----> set -q argv[1]
14	14	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
25	25	-----> argparse -n type -x t,p,P $options -- $argv
0	5	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
5	5	------> set -q _flag_help
4	4	-----> set -l res 1
4	4	-----> set -l mode normal
4	4	-----> set -l multi no
5	5	-----> set -l selection all
4	4	-----> set -l short no
3	10	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
3	3	------> set -q _flag_quiet
4	4	------> set mode quiet
3	3	-----> set -q _flag_all
3	3	-----> set -q _flag_short
3	3	-----> set -q _flag_no_functions
10	287	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
4	4	------> set -l found 0
10	165	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
6	6	-------> test $selection != files
1	23	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
22	22	--------> functions -q -- $i
2	126	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
103	124	--------> contains -- $i (builtin -n)
21	21	---------> builtin -n
6	6	------> set -l paths
2	85	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
6	6	-------> test $multi != yes
31	77	-------> set paths (command -s -- $i)
46	46	--------> command -s -- $i
5	5	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
2	12	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
5	5	-------> test $found = 0
5	5	-------> test $mode != quiet
4	4	-----> return $res
30	345	----> type -p -q pkgfile
4	4	-----> set -q argv[1]
11	11	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
23	23	-----> argparse -n type -x t,p,P $options -- $argv
1	4	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
3	3	------> set -q _flag_help
4	4	-----> set -l res 1
4	4	-----> set -l mode normal
4	4	-----> set -l multi no
4	4	-----> set -l selection all
4	4	-----> set -l short no
2	9	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
3	3	------> set -q _flag_quiet
4	4	------> set mode quiet
3	3	-----> set -q _flag_all
3	3	-----> set -q _flag_short
3	3	-----> set -q _flag_no_functions
12	231	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
4	4	------> set -l found 0
4	127	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
5	5	-------> test $selection != files
2	18	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
16	16	--------> functions -q -- $i
0	100	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
79	100	--------> contains -- $i (builtin -n)
21	21	---------> builtin -n
5	5	------> set -l paths
1	68	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
5	5	-------> test $multi != yes
30	62	-------> set paths (command -s -- $i)
32	32	--------> command -s -- $i
4	4	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
3	11	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
4	4	-------> test $found = 0
4	4	-------> test $mode != quiet
4	4	-----> return $res
6	6	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            ...
9	9	--> set __fish_initialized 3100
7	7	-> functions -e __fish_on_interactive
10	164	> __async_prompt_setup_on_startup
30	39	-> functions -e (status current-function)
9	9	--> status current-function
23	115	-> for func in (__async_prompt_config_functions)
        function $func -V func
            test -e $__async_prompt_tmpdir'/'$fish_pid'_'$func
            and cat $__async_prompt_tmpdir'/'$fish_pid'_'$func
        end
    ...
8	92	--> __async_prompt_config_functions
64	80	---> set -l funcs (
        if set -q $async_prompt_functions
            string join \n $async_prompt_functions
        else
            echo fish_prompt
            echo fish_right_prompt
        end
    )
3	16	----> if set -q $async_prompt_functions
            string join \n $async_prompt_functions
        else
            echo fish_prompt
            echo fish_right_prompt
        ...
6	6	-----> set -q $async_prompt_functions
7	7	-----> string join \n $async_prompt_functions
4	4	---> for func in $funcs
        functions -q "$func"
        or continue

        echo $func
    ...
7	106	> __async_prompt_fire
8	8	-> set st $status
23	91	-> for func in (__async_prompt_config_functions)
        set -l tmpfile $__async_prompt_tmpdir'/'$fish_pid'_'$func

        if functions -q $func'_loading_indicator' && test -e $tmpfile
            read -zl last_prompt <$tmpfile
            eval (string escape -- $func'_loading_indicator' "$last_prompt") >$tmpfile
        end

        __async_prompt_config_inherit_variables | __async_prompt_spawn $st \
            $func' | read -z prompt
            echo -n $prompt >'$tmpfile
    ...
8	68	--> __async_prompt_config_functions
44	57	---> set -l funcs (
        if set -q $async_prompt_functions
            string join \n $async_prompt_functions
        else
            echo fish_prompt
            echo fish_right_prompt
        end
    )
1	13	----> if set -q $async_prompt_functions
            string join \n $async_prompt_functions
        else
            echo fish_prompt
            echo fish_right_prompt
        ...
5	5	-----> set -q $async_prompt_functions
7	7	-----> string join \n $async_prompt_functions
3	3	---> for func in $funcs
        functions -q "$func"
        or continue

        echo $func
    ...
9	39884	> _pyenv_virtualenv_hook
7	7	-> set -l ret $status
3	39863	-> if [ -n "$VIRTUAL_ENV" ]
    pyenv activate --quiet; or pyenv deactivate --quiet; or true
  else
    pyenv activate --quiet; or true
  ...
6	6	--> [ -n "$VIRTUAL_ENV" ]
10	39851	--> pyenv activate --quiet
6	6	---> set command $argv[1]
5	5	---> set -e argv[1]
6	39830	---> switch "$command"
  case activate deactivate rehash shell
    source (pyenv "sh-$command" $argv|psub)
  case '*'
    command pyenv "$command" $argv
  ...
67	39824	----> source (pyenv "sh-$command" $argv|psub)
149	39744	-----> pyenv "sh-$command" $argv|psub
177	183	------> source /usr/share/fish/functions/psub.fish
6	6	-------> function psub --description "Read from stdin into a file and output the filename. Remove the file when the command that called psub exits."
    set -l options -x 'f,F' -x 'F,s' 'h/help' 'f/file' 'F/fifo' 's/suffix=' 'T-testing'
    argparse -n psub --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help psub
        return 0
    end

    set -l dirname
    set -l filename
    set -l funcname

    if not status --is-command-substitution
        printf (_ "%s: Not inside of command substitution") psub >&2
        return 1
    end

    set -l tmpdir /tmp
    set -q TMPDIR
    and set tmpdir $TMPDIR

    if set -q _flag_fifo
        # Write output to pipe. This needs to be done in the background so
        # that the command substitution exits without needing to wait for
        # all the commands to exit.
        set dirname (mktemp -d $tmpdir/.psub.XXXXXXXXXX)
        or return
        set filename $dirname/psub.fifo"$_flag_suffix"
        command mkfifo $filename
        # Note that if we were to do the obvious `cat >$filename &`, we would deadlock
        # because $filename may be opened before the fork. Use tee to ensure it is opened
        # after the fork.
        command tee $filename >/dev/null &
    else if test -z "$_flag_suffix"
        set filename (mktemp $tmpdir/.psub.XXXXXXXXXX)
        command cat >$filename
    else
        set dirname (mktemp -d $tmpdir/.psub.XXXXXXXXXX)
        set filename "$dirname/psub$_flag_suffix"
        command cat >$filename
    end

    # Write filename to stdout
    echo $filename

    # This flag isn't documented. It's strictly for our unit tests.
    if set -q _flag_testing
        return
    end

    # Find unique function name
    while true
        set funcname __fish_psub_(random)
        if not functions $funcname >/dev/null 2>/dev/null
            break
        end
    end

    # Make sure we erase file when caller exits
    function $funcname --on-job-exit caller --inherit-variable filename --inherit-variable dirname --inherit-variable funcname
        command rm $filename
        if test -n "$dirname"
            command rmdir $dirname
        end
        functions -e $funcname
    end

...
9	9	------> set command $argv[1]
5	5	------> set -e argv[1]
12	38406	------> switch "$command"
  case activate deactivate rehash shell
    source (pyenv "sh-$command" $argv|psub)
  case '*'
    command pyenv "$command" $argv
  ...
38394	38394	-------> command pyenv "$command" $argv
31	31	------> set -l options -x 'f,F' -x 'F,s' 'h/help' 'f/file' 'F/fifo' 's/suffix=' 'T-testing'
23	23	------> argparse -n psub --max-args=0 $options -- $argv
2	7	------> if set -q _flag_help
        __fish_print_help psub
        return 0
    ...
5	5	-------> set -q _flag_help
4	4	------> set -l dirname
3	3	------> set -l filename
4	4	------> set -l funcname
1	6	------> if not status --is-command-substitution
        printf (_ "%s: Not inside of command substitution") psub >&2
        return 1
    ...
5	5	-------> not status --is-command-substitution
4	4	------> set -l tmpdir /tmp
3	3	------> set -q TMPDIR
4	769	------> if set -q _flag_fifo
        # Write output to pipe. This needs to be done in the background so
        # that the command substitution exits without needing to wait for
        # all the commands to exit.
        set dirname (mktemp -d $tmpdir/.psub.XXXXXXXXXX)
        or return
        set filename $dirname/psub.fifo"$_flag_suffix"
        command mkfifo $filename
        # Note that if we were to do the obvious `cat >$filename &`, we would deadlock
        # because $filename may be opened before the fork. Use tee to ensure it is opened
        # after the fork.
        command tee $filename >/dev/null &
    else if test -z "$_flag_suffix"
        set filename (mktemp $tmpdir/.psub.XXXXXXXXXX)
        command cat >$filename
    else
        set dirname (mktemp -d $tmpdir/.psub.XXXXXXXXXX)
        set filename "$dirname/psub$_flag_suffix"
        command cat >$filename
    ...
3	3	-------> set -q _flag_fifo
6	6	-------> test -z "$_flag_suffix"
61	465	-------> set filename (mktemp $tmpdir/.psub.XXXXXXXXXX)
404	404	--------> mktemp $tmpdir/.psub.XXXXXXXXXX
291	291	-------> command cat >$filename
10	10	------> echo $filename
2	5	------> if set -q _flag_testing
        return
    ...
3	3	-------> set -q _flag_testing
2	110	------> while true
        set funcname __fish_psub_(random)
        if not functions $funcname >/dev/null 2>/dev/null
            break
        end
    ...
5	5	-------> true
42	62	-------> set funcname __fish_psub_(random)
20	20	--------> random
4	41	-------> if not functions $funcname >/dev/null 2>/dev/null
            break
        ...
35	35	--------> not functions $funcname >/dev/null 2>/dev/null
2	2	--------> break
13	13	------> function $funcname --on-job-exit caller --inherit-variable filename --inherit-variable dirname --inherit-variable funcname
        command rm $filename
        if test -n "$dirname"
            command rmdir $dirname
        end
        functions -e $funcname
    ...
13	13	-----> false
3	3	--> true
5	5	-> return $ret
26	31	> source /usr/share/fish/functions/fish_mode_prompt.fish
5	5	-> function fish_mode_prompt --description "Displays the current mode"
    # To reuse the mode indicator use this function instead
    fish_default_mode_prompt
...
9	207	> fish_mode_prompt
57	198	-> fish_default_mode_prompt
77	81	--> source /usr/share/fish/functions/fish_default_mode_prompt.fish
4	4	---> function fish_default_mode_prompt --description "Display the default mode for the prompt"
    # Do nothing if not in vi mode
    if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    end
...
5	60	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
9	9	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
6	36	---> switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        ...
25	25	----> set_color --bold --background green white
5	5	----> echo '[I]'
5	5	---> set_color normal
5	5	---> echo -n ' '
20	11678	> fish_prompt
10	10	-> set -l last_pipestatus $pipestatus
40	47	-> set -l normal (set_color normal)
7	7	--> set_color normal
6	6	-> set -l color_cwd $fish_color_cwd
4	4	-> set -l prefix
4	4	-> set -l suffix '>'
1	8	-> if contains -- $USER root toor
        if set -q fish_color_cwd_root
            set color_cwd $fish_color_cwd_root
        end
        set suffix '#'
    ...
7	7	--> contains -- $USER root toor
6	6	-> set -l color_host $fish_color_host
2	5	-> if set -q SSH_TTY
        set color_host $fish_color_host_remote
    ...
3	3	--> set -q SSH_TTY
41	346	-> set -l prompt_status (__fish_print_pipestatus " [" "]" "|" (set_color $fish_color_status) (set_color --bold $fish_color_status) $last_pipestatus)
128	305	--> __fish_print_pipestatus " [" "]" "|" (set_color $fish_color_status) (set_color --bold $fish_color_status) $last_pipestatus
91	96	---> source /usr/share/fish/functions/__fish_print_pipestatus.fish
5	5	----> function __fish_print_pipestatus --description "Print pipestatus for prompt"
    set -l left_brace $argv[1]
    set -l right_brace $argv[2]
    set -l separator $argv[3]
    set -l brace_sep_color $argv[4]
    set -l status_color $argv[5]
    set -e argv[1 2 3 4 5]

    # only output status codes if some process in the pipe failed
    # SIGPIPE (141 = 128 + 13) is usually not a failure, see #6375.
    if string match -qvr '^(0|141)$' $argv
        set -l sep (set_color normal){$brace_sep_color}{$separator}(set_color normal){$status_color}
        set -l last_pipestatus_string (string join "$sep" (__fish_pipestatus_with_signal $argv))
        printf "%s%s%s%s%s%s%s%s%s%s" (set_color normal )$brace_sep_color $left_brace \
            (set_color normal) $status_color $last_pipestatus_string (set_color normal) \
            $brace_sep_color $right_brace (set_color normal)
    end
...
13	13	---> set_color $fish_color_status
11	11	---> set_color --bold $fish_color_status
7	7	---> set -l left_brace $argv[1]
6	6	---> set -l right_brace $argv[2]
6	6	---> set -l separator $argv[3]
6	6	---> set -l brace_sep_color $argv[4]
6	6	---> set -l status_color $argv[5]
6	6	---> set -e argv[1 2 3 4 5]
1	20	---> if string match -qvr '^(0|141)$' $argv
        set -l sep (set_color normal){$brace_sep_color}{$separator}(set_color normal){$status_color}
        set -l last_pipestatus_string (string join "$sep" (__fish_pipestatus_with_signal $argv))
        printf "%s%s%s%s%s%s%s%s%s%s" (set_color normal )$brace_sep_color $left_brace \
            (set_color normal) $status_color $last_pipestatus_string (set_color normal) \
            $brace_sep_color $right_brace (set_color normal)
    ...
19	19	----> string match -qvr '^(0|141)$' $argv
225	11222	-> echo -n -s (set_color $fish_color_user) "$USER" $normal @ (set_color $color_host) (prompt_hostname) $normal ' ' (set_color $color_cwd) (prompt_pwd) $normal (fish_vcs_prompt) $normal $prompt_status $suffix " "
11	11	--> set_color $fish_color_user
9	9	--> set_color $color_host
47	94	--> prompt_hostname
29	32	---> source /usr/share/fish/functions/prompt_hostname.fish
3	3	----> function prompt_hostname
    # return the short hostname only by default (#4804)
    string replace -r "\..*" "" $hostname
...
15	15	---> string replace -r "\..*" "" $hostname
11	11	--> set_color $color_cwd
52	257	--> prompt_pwd
79	84	---> source /usr/share/fish/functions/prompt_pwd.fish
5	5	----> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
8	8	---> set -l options 'h/help'
9	9	---> argparse -n prompt_pwd --max-args=0 $options -- $argv
1	4	---> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
3	3	----> set -q _flag_help
4	4	---> set -q fish_prompt_pwd_dir_length
5	5	---> set -l fish_prompt_pwd_dir_length 1
7	7	---> set realhome ~
43	59	---> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
16	16	----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
2	25	---> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
8	8	----> [ $fish_prompt_pwd_dir_length -eq 0 ]
15	15	----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
49	10615	--> fish_vcs_prompt
38	43	---> source /usr/share/fish/functions/fish_vcs_prompt.fish
5	5	----> function fish_vcs_prompt --description "Print the prompts for all available vcsen"
    # If a prompt succeeded, we assume that it's printed the correct info.
    # This is so we don't try svn if git already worked.
    fish_git_prompt
    or fish_hg_prompt
    # The svn prompt is disabled by default because it's quite slow on common svn repositories.
    # To enable it uncomment it.
    # You can also only use it in specific directories by checking $PWD.
    # or fish_svn_prompt
...
90	10523	---> fish_git_prompt
1742	2223	----> source /usr/share/fish/functions/fish_git_prompt.fish
6	6	-----> function __fish_git_prompt_show_upstream --description "Helper function for fish_git_prompt"
    set -q __fish_git_prompt_showupstream
    or set -l __fish_git_prompt_showupstream
    set -l show_upstream $__fish_git_prompt_showupstream
    set -l svn_prefix # For better SVN upstream information
    set -l informative

    set -l svn_url_pattern
    set -l count
    set -l upstream git
    set -l verbose
    set -l name

    # Default to informative if __fish_git_prompt_show_informative_status is set
    if set -q __fish_git_prompt_show_informative_status
        set informative 1
    end

    set -l svn_remote
    # get some config options from git-config
    command git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | while read -lz key value
        switch $key
            case bash.showupstream
                set show_upstream $value
                test -n "$show_upstream"
                or return
            case svn-remote.'*'.url
                set svn_remote $svn_remote $value
                # Avoid adding \| to the beginning to avoid needing #?? later
                if test -n "$svn_url_pattern"
                    set svn_url_pattern $svn_url_pattern"|$value"
                else
                    set svn_url_pattern $value
                end
                set upstream svn+git # default upstream is SVN if available, else git

                # Save the config key (without .url) for later use
                set -l remote_prefix (string replace -r '\.url$' '' -- $key)
                set svn_prefix $svn_prefix $remote_prefix
        end
    end

    # parse configuration variables
    # and clear informative default when needed
    for option in $show_upstream
        switch $option
            case git svn
                set upstream $option
                set -e informative
            case verbose
                set verbose 1
                set -e informative
            case informative
                set informative 1
            case name
                set name 1
            case none
                return
        end
    end

    # Find our upstream
    switch $upstream
        case git
            set upstream '@{upstream}'
        case svn\*
            # get the upstream from the 'git-svn-id: …' in a commit message
            # (git-svn uses essentially the same procedure internally)
            set -l svn_upstream (git log --first-parent -1 --grep="^git-svn-id: \($svn_url_pattern\)" 2>/dev/null)
            if test (count $svn_upstream) -ne 0
                echo $svn_upstream[-1] | read -l __ svn_upstream __
                set svn_upstream (string replace -r '@.*' '' -- $svn_upstream)
                set -l cur_prefix
                for i in (seq (count $svn_remote))
                    set -l remote $svn_remote[$i]
                    set -l mod_upstream (string replace "$remote" "" -- $svn_upstream)
                    if test "$svn_upstream" != "$mod_upstream"
                        # we found a valid remote
                        set svn_upstream $mod_upstream
                        set cur_prefix $svn_prefix[$i]
                        break
                    end
                end

                if test -z "$svn_upstream"
                    # default branch name for checkouts with no layout:
                    if test -n "$GIT_SVN_ID"
                        set upstream $GIT_SVN_ID
                    else
                        set upstream git-svn
                    end
                else
                    set upstream (string replace '/branches' '' -- $svn_upstream | string replace -a '/' '')

                    # Use fetch config to fix upstream
                    set -l fetch_val (command git config "$cur_prefix".fetch)
                    if test -n "$fetch_val"
                        string split -m1 : -- "$fetch_val" | read -l trunk pattern
                        set upstream (string replace -r -- "/$trunk\$" '' $pattern) /$upstream
                    end
                end
            else if test $upstream = svn+git
                set upstream '@{upstream}'
            end
    end

    # Find how many commits we are ahead/behind our upstream
    set count (command git rev-list --count --left-right $upstream...HEAD 2>/dev/null | string replace \t " ")

    # calculate the result
    if test -n "$verbose"
        # Verbose has a space by default
        set -l prefix "$___fish_git_prompt_char_upstream_prefix"
        # Using two underscore version to check if user explicitly set to nothing
        if not set -q __fish_git_prompt_char_upstream_prefix
            set prefix " "
        end

        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$prefix$___fish_git_prompt_char_upstream_diverged$ahead-$behind"
        end
        if test -n "$count" -a -n "$name"
            echo " "(command git rev-parse --abbrev-ref "$upstream" 2>/dev/null)
        end
    else if test -n "$informative"
        echo $count | read -l behind ahead
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind$behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead$ahead$___fish_git_prompt_char_upstream_behind$behind"
        end
    else
        switch "$count"
            case '' # no upstream
            case "0 0" # equal to upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_equal"
            case "0 *" # ahead of upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_ahead"
            case "* 0" # behind upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_behind"
            case '*' # diverged from upstream
                echo "$___fish_git_prompt_char_upstream_prefix$___fish_git_prompt_char_upstream_diverged"
        end
    end

    # For the return status
    test "$count" = "0 0"
...
3	3	-----> function fish_git_prompt --description "Prompt function for Git"
    # If git isn't installed, there's nothing we can do
    # Return 1 so the calling prompt can deal with it
    if not command -sq git
        return 1
    end
    set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
    test -n "$repo_info"
    or return

    set -l git_dir $repo_info[1]
    set -l inside_gitdir $repo_info[2]
    set -l bare_repo $repo_info[3]
    set -l inside_worktree $repo_info[4]
    set -q repo_info[5]
    and set -l sha $repo_info[5]

    set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
    set -l r $rbc[1] # current operation
    set -l b $rbc[2] # current branch
    set -l detached $rbc[3]
    set -l w #dirty working directory
    set -l i #staged changes
    set -l s #stashes
    set -l u #untracked
    set -l c $rbc[4] # bare repository
    set -l p #upstream
    set -l informative_status

    if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    end

    set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"

    # Use our variables as defaults, but allow overrides via the local git config.
    # That means if neither is set, this stays empty.
    #
    # So "!= true" or "!= false" are useful tests if you want to do something by default.
    set -l informative (command git config --bool bash.showInformativeStatus)

    set -l dirty (command git config --bool bash.showDirtyState)
    if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    end

    set -l untracked (command git config --bool bash.showUntrackedFiles)
    if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    end

    if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    end

    set -l branch_color $___fish_git_prompt_color_branch
    set -l branch_done $___fish_git_prompt_color_branch_done
    if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    end

    if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    end
    if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    end
    if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    end
    if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    end

    set b (string replace refs/heads/ '' -- $b)
    set -q __fish_git_prompt_shorten_branch_char_suffix
    or set -l __fish_git_prompt_shorten_branch_char_suffix "…"
    if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    end
    if test -n "$b"
        set b "$branch_color$b$branch_done"
    end

    if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    end
    if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    end
    if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    end

    # Formatting
    set -l f "$w$i$s$u"
    if test -n "$f"
        set f "$space$f"
    end
    set -l format $argv[1]
    if test -z "$format"
        set format " (%s)"
    end

    printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
...
3	3	-----> function __fish_git_prompt_staged --description "fish_git_prompt helper, tells whether or not the current branch has staged files"
    set -l sha $argv[1]
    set -l staged
    set -l ret 0

    if test -n "$sha"
        # The "diff" functions all return > 0 if there _is_ a diff,
        # but we want to return 0 if there are staged changes.
        # So we invert the status.
        not command git diff-index --cached --quiet HEAD -- 2>/dev/null
        and set staged $___fish_git_prompt_char_stagedstate
        set ret $status
    else
        set staged $___fish_git_prompt_char_invalidstate
        set ret 2
    end
    echo $staged
    return $ret
...
3	3	-----> function __fish_git_prompt_untracked --description "fish_git_prompt helper, tells whether or not the current repository has untracked files"
    set -l ret 1
    if command git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- :/ >/dev/null 2>&1
        set ret $status
        set untracked $___fish_git_prompt_char_untrackedfiles
    end
    echo $untracked
    return $ret
...
4	4	-----> function __fish_git_prompt_dirty --description "fish_git_prompt helper, tells whether or not the current branch has tracked, modified files"
    set -l dirty

    # Like staged, invert the status because we want 0 to mean there are dirty files.
    not command git diff --no-ext-diff --quiet --exit-code 2>/dev/null
    set -l os $status
    if test $os -eq 0
        set dirty $___fish_git_prompt_char_dirtystate
    end
    echo $dirty
    return $os
...
11	11	-----> set -g ___fish_git_prompt_status_order stagedstate invalidstate dirtystate untrackedfiles
2	6	-----> if set -q __fish_git_prompt_showstashstate
    set -a ___fish_git_prompt_status_order stashstate
...
4	4	------> set -q __fish_git_prompt_showstashstate
2	2	-----> function __fish_git_prompt_informative_status

    set -l changedFiles (command git diff --name-status 2>/dev/null | string match -r \\w)
    set -l stagedFiles (command git diff --staged --name-status | string match -r \\w)

    set -l x (count $changedFiles)
    set -l y (count (string match -r "U" -- $changedFiles))
    set -l dirtystate (math $x - $y)
    set -l x (count $stagedFiles)
    set -l invalidstate (count (string match -r "U" -- $stagedFiles))
    set -l stagedstate (math $x - $invalidstate)
    set -l untrackedfiles (command git ls-files --others --exclude-standard | count)
    set -l stashstate 0
    set -l stashfile "$argv[1]/logs/refs/stash"
    if set -q __fish_git_prompt_showstashstate; and test -e "$stashfile"
        set stashstate (count < $stashfile)
    end

    set -l info

    # If `math` fails for some reason, assume the state is clean - it's the simpler path
    set -l state (math $dirtystate + $invalidstate + $stagedstate + $untrackedfiles + $stashstate 2>/dev/null)
    if test -z "$state"
        or test "$state" = 0
        set info $___fish_git_prompt_color_cleanstate$___fish_git_prompt_char_cleanstate$___fish_git_prompt_color_cleanstate_done
    else
        for i in $___fish_git_prompt_status_order
            if [ $$i != "0" ]
                set -l color_var ___fish_git_prompt_color_$i
                set -l color_done_var ___fish_git_prompt_color_{$i}_done
                set -l symbol_var ___fish_git_prompt_char_$i

                set -l color $$color_var
                set -l color_done $$color_done_var
                set -l symbol $$symbol_var

                set -l count

                if not set -q __fish_git_prompt_hide_$i
                    set count $$i
                end

                set info "$info$color$symbol$count$color_done"
            end
        end
    end

    echo $info

...
4	4	-----> function __fish_git_prompt_operation_branch_bare --description "fish_git_prompt helper, returns the current Git operation and branch"
    # This function is passed the full repo_info array
    set -l git_dir $argv[1]
    set -l inside_gitdir $argv[2]
    set -l bare_repo $argv[3]
    set -q argv[5]
    and set -l sha $argv[5]

    set -l branch
    set -l operation
    set -l detached no
    set -l bare
    set -l step
    set -l total
    set -l os

    if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    end

    if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    end

    if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    end

    if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    end

    echo $operation
    echo $branch
    echo $detached
    echo $bare
...
2	2	-----> function __fish_git_prompt_set_char
    set -l user_variable_name "$argv[1]"
    set -l char $argv[2]
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end

    if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    end
...
3	3	-----> function __fish_git_prompt_validate_chars --description "fish_git_prompt helper, checks char variables"

    __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
    __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
    __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
    __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
    __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
    __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
    __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
    __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''

...
1	1	-----> function __fish_git_prompt_set_color
    set -l user_variable_name "$argv[1]"
    set -l user_variable
    if set -q $user_variable_name
        set user_variable $$user_variable_name
    end
    set -l user_variable_bright

    set -l default default_done
    switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    end

    set -l variable _$user_variable_name
    set -l variable_done "$variable"_done

    if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    end

...
3	3	-----> function __fish_git_prompt_validate_colors --description "fish_git_prompt helper, checks color variables"

    # Base color defaults to nothing (must be done first)
    __fish_git_prompt_set_color __fish_git_prompt_color '' ''

    # Normal colors
    __fish_git_prompt_set_color __fish_git_prompt_color_prefix
    __fish_git_prompt_set_color __fish_git_prompt_color_suffix
    __fish_git_prompt_set_color __fish_git_prompt_color_bare
    __fish_git_prompt_set_color __fish_git_prompt_color_merging
    __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
    __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
    __fish_git_prompt_set_color __fish_git_prompt_color_upstream

    # Colors with defaults with showcolorhints
    if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    end

    # Branch_detached has a default, but is only used with showcolorhints
    __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)

    # Colors that depend on flags color
    __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done

...
5	5	-----> set -l varargs
48	98	-----> for var in repaint describe_style show_informative_status use_informative_chars showdirtystate showstashstate showuntrackedfiles showupstream
    set -a varargs --on-variable __fish_git_prompt_$var
...
8	8	------> set -a varargs --on-variable __fish_git_prompt_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_$var
18	18	-----> function __fish_git_prompt_repaint $varargs --description "Event handler, repaints prompt when functionality changes"
    if status --is-interactive
        if test $argv[3] = __fish_git_prompt_show_informative_status
            # Clear characters that have different defaults with/without informative status
            for name in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind
                set -e ___fish_git_prompt_char_$name
            end
            # Clear init so we reset the chars next time.
            set -e ___fish_git_prompt_init
        end

        commandline -f repaint 2>/dev/null
    end
...
4	4	-----> set -l varargs
31	136	-----> for var in '' _prefix _suffix _bare _merging _cleanstate _invalidstate _upstream _flags _branch _dirtystate _stagedstate _branch_detached _stashstate _untrackedfiles
    set -a varargs --on-variable __fish_git_prompt_color$var
...
7	7	------> set -a varargs --on-variable __fish_git_prompt_color$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_color$var
5	5	------> set -a varargs --on-variable __fish_git_prompt_color$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_color$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_color$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_color$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_color$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_color$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_color$var
7	7	------> set -a varargs --on-variable __fish_git_prompt_color$var
8	8	------> set -a varargs --on-variable __fish_git_prompt_color$var
9	9	------> set -a varargs --on-variable __fish_git_prompt_color$var
8	8	------> set -a varargs --on-variable __fish_git_prompt_color$var
9	9	------> set -a varargs --on-variable __fish_git_prompt_color$var
10	10	------> set -a varargs --on-variable __fish_git_prompt_color$var
8	8	-----> set -a varargs --on-variable __fish_git_prompt_showcolorhints
29	29	-----> function __fish_git_prompt_repaint_color $varargs --description "Event handler, repaints prompt when any color changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -l var $argv[3]
        set -e _$var
        set -e _{$var}_done
        if test $var = __fish_git_prompt_color -o $var = __fish_git_prompt_color_flags -o $var = __fish_git_prompt_showcolorhints
            # reset all the other colors too
            for name in prefix suffix bare merging branch dirtystate stagedstate invalidstate stashstate untrackedfiles upstream flags
                set -e ___fish_git_prompt_color_$name
                set -e ___fish_git_prompt_color_{$name}_done
            end
        end
        commandline -f repaint 2>/dev/null
    end
...
5	5	-----> set -l varargs
24	104	-----> for var in cleanstate dirtystate invalidstate stagedstate stashstate stateseparator untrackedfiles upstream_ahead upstream_behind upstream_diverged upstream_equal upstream_prefix
    set -a varargs --on-variable __fish_git_prompt_char_$var
...
6	6	------> set -a varargs --on-variable __fish_git_prompt_char_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_char_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_char_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_char_$var
7	7	------> set -a varargs --on-variable __fish_git_prompt_char_$var
6	6	------> set -a varargs --on-variable __fish_git_prompt_char_$var
8	8	------> set -a varargs --on-variable __fish_git_prompt_char_$var
7	7	------> set -a varargs --on-variable __fish_git_prompt_char_$var
7	7	------> set -a varargs --on-variable __fish_git_prompt_char_$var
7	7	------> set -a varargs --on-variable __fish_git_prompt_char_$var
7	7	------> set -a varargs --on-variable __fish_git_prompt_char_$var
7	7	------> set -a varargs --on-variable __fish_git_prompt_char_$var
23	23	-----> function __fish_git_prompt_repaint_char $varargs --description "Event handler, repaints prompt when any char changes"
    if status --is-interactive
        set -e ___fish_git_prompt_init
        set -e _$argv[3]
        commandline -f repaint 2>/dev/null
    end
...
3	25	----> if not command -sq git
        return 1
    ...
22	22	-----> not command -sq git
74	804	----> set -l repo_info (command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null)
730	730	-----> command git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree HEAD 2>/dev/null
7	7	----> test -n "$repo_info"
6	6	----> set -l git_dir $repo_info[1]
5	5	----> set -l inside_gitdir $repo_info[2]
6	6	----> set -l bare_repo $repo_info[3]
6	6	----> set -l inside_worktree $repo_info[4]
5	5	----> set -q repo_info[5]
6	6	----> set -l sha $repo_info[5]
45	808	----> set -l rbc (__fish_git_prompt_operation_branch_bare $repo_info)
35	763	-----> __fish_git_prompt_operation_branch_bare $repo_info
7	7	------> set -l git_dir $argv[1]
6	6	------> set -l inside_gitdir $argv[2]
6	6	------> set -l bare_repo $argv[3]
4	4	------> set -q argv[5]
5	5	------> set -l sha $argv[5]
3	3	------> set -l branch
4	4	------> set -l operation
4	4	------> set -l detached no
4	4	------> set -l bare
4	4	------> set -l step
4	4	------> set -l total
4	4	------> set -l os
24	61	------> if test -d $git_dir/rebase-merge
        set branch (cat $git_dir/rebase-merge/head-name 2>/dev/null)
        set step (cat $git_dir/rebase-merge/msgnum 2>/dev/null)
        set total (cat $git_dir/rebase-merge/end 2>/dev/null)
        if test -f $git_dir/rebase-merge/interactive
            set operation "|REBASE-i"
        else
            set operation "|REBASE-m"
        end
    else
        if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        end
    ...
7	7	-------> test -d $git_dir/rebase-merge
5	30	-------> if test -d $git_dir/rebase-apply
            set step (cat $git_dir/rebase-apply/next 2>/dev/null)
            set total (cat $git_dir/rebase-apply/last 2>/dev/null)
            if test -f $git_dir/rebase-apply/rebasing
                set branch (cat $git_dir/rebase-apply/head-name 2>/dev/null)
                set operation "|REBASE"
            else if test -f $git_dir/rebase-apply/applying
                set operation "|AM"
            else
                set operation "|AM/REBASE"
            end
        else if test -f $git_dir/MERGE_HEAD
            set operation "|MERGING"
        else if test -f $git_dir/CHERRY_PICK_HEAD
            set operation "|CHERRY-PICKING"
        else if test -f $git_dir/REVERT_HEAD
            set operation "|REVERTING"
        else if test -f $git_dir/BISECT_LOG
            set operation "|BISECTING"
        ...
6	6	--------> test -d $git_dir/rebase-apply
5	5	--------> test -f $git_dir/MERGE_HEAD
5	5	--------> test -f $git_dir/CHERRY_PICK_HEAD
5	5	--------> test -f $git_dir/REVERT_HEAD
4	4	--------> test -f $git_dir/BISECT_LOG
1	8	------> if test -n "$step" -a -n "$total"
        set operation "$operation $step/$total"
    ...
7	7	-------> test -n "$step" -a -n "$total"
5	575	------> if test -z "$branch"
        set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
        if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        end
    ...
4	4	-------> test -z "$branch"
44	559	-------> set branch (command git symbolic-ref HEAD 2>/dev/null; set os $status)
506	506	--------> command git symbolic-ref HEAD 2>/dev/null
9	9	--------> set os $status
1	7	-------> if test $os -ne 0
            set detached yes
            set branch (switch "$__fish_git_prompt_describe_style"
						case contains
							command git describe --contains HEAD
						case branch
							command git describe --contains --all HEAD
						case describe
							command git describe HEAD
						case default '*'
							command git describe --tags --exact-match HEAD
						end 2>/dev/null; set os $status)
            if test $os -ne 0
                # Shorten the sha ourselves to 8 characters - this should be good for most repositories,
                # and even for large ones it should be good for most commits
                if set -q sha
                    set branch (string match -r '^.{8}' -- $sha)…
                else
                    set branch unknown
                end
            end
            set branch "($branch)"
        ...
6	6	--------> test $os -ne 0
1	7	------> if test "true" = $inside_gitdir
        if test "true" = $bare_repo
            set bare "BARE:"
        else
            # Let user know they're inside the git dir of a non-bare repo
            set branch "GIT_DIR!"
        end
    ...
6	6	-------> test "true" = $inside_gitdir
7	7	------> echo $operation
6	6	------> echo $branch
5	5	------> echo $detached
4	4	------> echo $bare
6	6	----> set -l r $rbc[1]
6	6	----> set -l b $rbc[2]
6	6	----> set -l detached $rbc[3]
4	4	----> set -l w
4	4	----> set -l i
4	4	----> set -l s
3	3	----> set -l u
5	5	----> set -l c $rbc[4]
3	3	----> set -l p
4	4	----> set -l informative_status
4	4447	----> if not set -q ___fish_git_prompt_init
        # This takes a while, so it only needs to be done once,
        # and then whenever the configuration changes.
        __fish_git_prompt_validate_chars
        __fish_git_prompt_validate_colors
        set -g ___fish_git_prompt_init
    ...
4	4	-----> not set -q ___fish_git_prompt_init
18	1826	-----> __fish_git_prompt_validate_chars
39	172	------> __fish_git_prompt_set_char __fish_git_prompt_char_cleanstate '✔'
7	7	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
3	7	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
1	4	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
27	94	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
5	5	--------> not set -q $variable
47	62	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
7	7	---------> set -q $user_variable_name
8	8	---------> echo $char
13	146	------> __fish_git_prompt_set_char __fish_git_prompt_char_dirtystate '*' '✚'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
1	38	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
4	4	--------> set -q argv[3]
27	33	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
3	3	---------> set -q __fish_git_prompt_show_informative_status
3	3	---------> set -q __fish_git_prompt_use_informative_chars
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	63	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
45	56	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
6	6	---------> echo $char
14	160	------> __fish_git_prompt_set_char __fish_git_prompt_char_invalidstate '#' '✖'
6	6	-------> set -l user_variable_name "$argv[1]"
6	6	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
3	39	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
27	33	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
3	3	---------> set -q __fish_git_prompt_show_informative_status
3	3	---------> set -q __fish_git_prompt_use_informative_chars
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
5	75	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
54	66	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
6	6	---------> set -q $user_variable_name
6	6	---------> echo $char
16	177	------> __fish_git_prompt_set_char __fish_git_prompt_char_stagedstate '+' '●'
7	7	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
0	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
5	5	--------> set -q $user_variable_name
4	53	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
39	46	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
4	4	---------> set -q __fish_git_prompt_show_informative_status
3	3	---------> set -q __fish_git_prompt_use_informative_chars
7	7	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
4	74	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
54	66	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
7	7	---------> echo $char
17	148	------> __fish_git_prompt_set_char __fish_git_prompt_char_stashstate '$' '⚑'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
2	37	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
25	32	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
4	4	---------> set -q __fish_git_prompt_show_informative_status
3	3	---------> set -q __fish_git_prompt_use_informative_chars
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
2	64	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
5	5	--------> not set -q $variable
46	57	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
6	6	---------> echo $char
15	140	------> __fish_git_prompt_set_char __fish_git_prompt_char_stateseparator ' ' '|'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
3	3	-------> set -l user_variable
0	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
5	5	--------> set -q $user_variable_name
1	38	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
4	4	--------> set -q argv[3]
27	33	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
3	3	---------> set -q __fish_git_prompt_show_informative_status
3	3	---------> set -q __fish_git_prompt_use_informative_chars
5	5	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	57	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
39	50	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
6	6	---------> echo $char
12	139	------> __fish_git_prompt_set_char __fish_git_prompt_char_untrackedfiles '%' '…'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
1	39	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
4	4	--------> set -q argv[3]
28	34	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
3	3	---------> set -q __fish_git_prompt_show_informative_status
3	3	---------> set -q __fish_git_prompt_use_informative_chars
5	5	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	57	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
5	5	--------> not set -q $variable
38	49	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
6	6	---------> echo $char
12	142	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_ahead '>' '↑'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	46	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
4	4	--------> set -q argv[3]
31	38	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
3	3	---------> set -q __fish_git_prompt_show_informative_status
4	4	---------> set -q __fish_git_prompt_use_informative_chars
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
3	54	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
37	47	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
5	5	---------> echo $char
14	149	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_behind '<' '↓'
5	5	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
3	38	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
26	32	--------> begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        ...
3	3	---------> set -q __fish_git_prompt_show_informative_status
3	3	---------> set -q __fish_git_prompt_use_informative_chars
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
2	67	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
50	61	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
6	6	---------> echo $char
16	137	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_diverged '<>'
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
2	6	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
1	4	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
25	85	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
45	56	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
6	6	---------> echo $char
13	136	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_equal '='
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
4	4	-------> set -l user_variable
2	6	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
1	4	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
26	88	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
4	4	--------> not set -q $variable
47	58	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
6	6	---------> echo $char
16	162	------> __fish_git_prompt_set_char __fish_git_prompt_char_upstream_prefix ''
6	6	-------> set -l user_variable_name "$argv[1]"
5	5	-------> set -l char $argv[2]
3	3	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
1	4	-------> if set -q argv[3]
        and begin set -q __fish_git_prompt_show_informative_status
            or set -q __fish_git_prompt_use_informative_chars
        end
        set char $argv[3]
    ...
3	3	--------> set -q argv[3]
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
26	113	-------> if not set -q $variable
        set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
    ...
5	5	--------> not set -q $variable
72	82	--------> set -g $variable (set -q $user_variable_name; and echo $user_variable; or echo $char)
5	5	---------> set -q $user_variable_name
5	5	---------> echo $char
23	2608	-----> __fish_git_prompt_validate_colors
44	198	------> __fish_git_prompt_set_color __fish_git_prompt_color '' ''
7	7	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
0	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
5	5	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
5	5	-------> set -l default default_done
64	90	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
12	12	--------> count $argv
8	8	--------> set default "$argv[2]"
6	6	--------> set default_done "$argv[3]"
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
1	28	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	--------> not set -q $variable
3	22	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
5	5	---------> test -n "$user_variable"
7	7	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
16	163	------> __fish_git_prompt_set_color __fish_git_prompt_color_prefix
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
2	6	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
64	85	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
8	8	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
2	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
4	4	--------> not set -q $variable
3	21	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
5	5	---------> test -n "$user_variable"
6	6	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
16	159	------> __fish_git_prompt_set_color __fish_git_prompt_color_suffix
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
2	6	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
61	82	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
8	8	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
2	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	--------> not set -q $variable
2	20	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	---------> test -n "$user_variable"
7	7	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
18	160	------> __fish_git_prompt_set_color __fish_git_prompt_color_bare
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
3	3	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
64	83	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
7	7	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
5	5	--------> set default_done $___fish_git_prompt_color_done
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
1	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	--------> not set -q $variable
4	21	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	---------> test -n "$user_variable"
6	6	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
14	160	------> __fish_git_prompt_set_color __fish_git_prompt_color_merging
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
2	6	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
5	5	-------> set -l default default_done
65	84	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
7	7	--------> count $argv
6	6	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
1	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	--------> not set -q $variable
3	21	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	---------> test -n "$user_variable"
7	7	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
17	163	------> __fish_git_prompt_set_color __fish_git_prompt_color_cleanstate
6	6	-------> set -l user_variable_name "$argv[1]"
3	3	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
67	87	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
8	8	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
5	5	--------> set default_done $___fish_git_prompt_color_done
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
2	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	--------> not set -q $variable
2	20	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
5	5	---------> test -n "$user_variable"
6	6	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
15	173	------> __fish_git_prompt_set_color __fish_git_prompt_color_invalidstate
6	6	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
2	6	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
75	96	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
8	8	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
3	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
4	4	--------> not set -q $variable
4	20	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	---------> test -n "$user_variable"
6	6	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
16	162	------> __fish_git_prompt_set_color __fish_git_prompt_color_upstream
6	6	-------> set -l user_variable_name "$argv[1]"
3	3	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
3	3	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
65	86	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
8	8	--------> count $argv
7	7	--------> set default $___fish_git_prompt_color
6	6	--------> set default_done $___fish_git_prompt_color_done
6	6	-------> set -l variable _$user_variable_name
6	6	-------> set -l variable_done "$variable"_done
3	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
4	4	--------> not set -q $variable
3	20	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	---------> test -n "$user_variable"
7	7	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
5	661	------> if set -q __fish_git_prompt_showcolorhints
        __fish_git_prompt_set_color __fish_git_prompt_color_flags (set_color --bold blue)
        __fish_git_prompt_set_color __fish_git_prompt_color_branch (set_color green)
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate (set_color red)
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate (set_color green)
    else
        __fish_git_prompt_set_color __fish_git_prompt_color_flags
        __fish_git_prompt_set_color __fish_git_prompt_color_branch
        __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
        __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
    ...
3	3	-------> set -q __fish_git_prompt_showcolorhints
16	163	-------> __fish_git_prompt_set_color __fish_git_prompt_color_flags
6	6	--------> set -l user_variable_name "$argv[1]"
4	4	--------> set -l user_variable
0	5	--------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
5	5	---------> set -q $user_variable_name
4	4	--------> set -l user_variable_bright
4	4	--------> set -l default default_done
64	86	--------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
10	10	---------> count $argv
7	7	---------> set default $___fish_git_prompt_color
5	5	---------> set default_done $___fish_git_prompt_color_done
6	6	--------> set -l variable _$user_variable_name
5	5	--------> set -l variable_done "$variable"_done
2	27	--------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
4	4	---------> not set -q $variable
3	21	---------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
5	5	----------> test -n "$user_variable"
6	6	----------> set -g $variable $default
7	7	----------> set -g $variable_done $default_done
15	162	-------> __fish_git_prompt_set_color __fish_git_prompt_color_branch
7	7	--------> set -l user_variable_name "$argv[1]"
4	4	--------> set -l user_variable
1	5	--------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	---------> set -q $user_variable_name
4	4	--------> set -l user_variable_bright
4	4	--------> set -l default default_done
67	86	--------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
7	7	---------> count $argv
7	7	---------> set default $___fish_git_prompt_color
5	5	---------> set default_done $___fish_git_prompt_color_done
5	5	--------> set -l variable _$user_variable_name
5	5	--------> set -l variable_done "$variable"_done
1	27	--------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	---------> not set -q $variable
3	21	---------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
5	5	----------> test -n "$user_variable"
6	6	----------> set -g $variable $default
7	7	----------> set -g $variable_done $default_done
19	164	-------> __fish_git_prompt_set_color __fish_git_prompt_color_dirtystate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
6	6	--------> set -l user_variable_name "$argv[1]"
4	4	--------> set -l user_variable
1	5	--------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	---------> set -q $user_variable_name
4	4	--------> set -l user_variable_bright
4	4	--------> set -l default default_done
62	83	--------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
9	9	---------> count $argv
6	6	---------> set default "$argv[2]"
6	6	---------> set default_done "$argv[3]"
6	6	--------> set -l variable _$user_variable_name
6	6	--------> set -l variable_done "$variable"_done
3	27	--------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
4	4	---------> not set -q $variable
2	20	---------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	----------> test -n "$user_variable"
7	7	----------> set -g $variable $default
7	7	----------> set -g $variable_done $default_done
21	164	-------> __fish_git_prompt_set_color __fish_git_prompt_color_stagedstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
6	6	--------> set -l user_variable_name "$argv[1]"
4	4	--------> set -l user_variable
1	5	--------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	---------> set -q $user_variable_name
4	4	--------> set -l user_variable_bright
4	4	--------> set -l default default_done
62	83	--------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
9	9	---------> count $argv
7	7	---------> set default "$argv[2]"
5	5	---------> set default_done "$argv[3]"
5	5	--------> set -l variable _$user_variable_name
5	5	--------> set -l variable_done "$variable"_done
3	27	--------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
4	4	---------> not set -q $variable
3	20	---------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	----------> test -n "$user_variable"
7	7	----------> set -g $variable $default
6	6	----------> set -g $variable_done $default_done
51	252	------> __fish_git_prompt_set_color __fish_git_prompt_color_branch_detached (set_color red)
12	12	-------> set_color red
8	8	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
2	6	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
62	123	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
8	8	--------> count $argv
7	7	--------> set default "$argv[2]"
39	46	--------> set default_done (set_color normal)
7	7	---------> set_color normal
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
3	29	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	--------> not set -q $variable
2	21	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
5	5	---------> test -n "$user_variable"
7	7	---------> set -g $variable $default
7	7	---------> set -g $variable_done $default_done
20	165	------> __fish_git_prompt_set_color __fish_git_prompt_color_stashstate $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
6	6	-------> set -l user_variable_name "$argv[1]"
3	3	-------> set -l user_variable
1	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
4	4	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
4	4	-------> set -l default default_done
63	85	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
9	9	--------> count $argv
7	7	--------> set default "$argv[2]"
6	6	--------> set default_done "$argv[3]"
5	5	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
3	28	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
5	5	--------> not set -q $variable
3	20	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
5	5	---------> test -n "$user_variable"
6	6	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
18	169	------> __fish_git_prompt_set_color __fish_git_prompt_color_untrackedfiles $___fish_git_prompt_color_flags $___fish_git_prompt_color_flags_done
5	5	-------> set -l user_variable_name "$argv[1]"
4	4	-------> set -l user_variable
0	5	-------> if set -q $user_variable_name
        set user_variable $$user_variable_name
    ...
5	5	--------> set -q $user_variable_name
4	4	-------> set -l user_variable_bright
5	5	-------> set -l default default_done
69	90	-------> switch (count $argv)
        case 1 # No defaults given, use prompt color
            set default $___fish_git_prompt_color
            set default_done $___fish_git_prompt_color_done
        case 2 # One default given, use normal for done
            set default "$argv[2]"
            set default_done (set_color normal)
        case 3 # Both defaults given
            set default "$argv[2]"
            set default_done "$argv[3]"
    ...
9	9	--------> count $argv
7	7	--------> set default "$argv[2]"
5	5	--------> set default_done "$argv[3]"
6	6	-------> set -l variable _$user_variable_name
5	5	-------> set -l variable_done "$variable"_done
3	27	-------> if not set -q $variable
        if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        end
    ...
4	4	--------> not set -q $variable
4	20	--------> if test -n "$user_variable"
            set -g $variable (set_color $user_variable)
            set -g $variable_done (set_color normal)
        else
            set -g $variable $default
            set -g $variable_done $default_done
        ...
4	4	---------> test -n "$user_variable"
6	6	---------> set -g $variable $default
6	6	---------> set -g $variable_done $default_done
5	5	-----> set -g ___fish_git_prompt_init
8	8	----> set -l space "$___fish_git_prompt_color$___fish_git_prompt_char_stateseparator$___fish_git_prompt_color_done"
47	653	----> set -l informative (command git config --bool bash.showInformativeStatus)
606	606	-----> command git config --bool bash.showInformativeStatus
53	587	----> set -l dirty (command git config --bool bash.showDirtyState)
534	534	-----> command git config --bool bash.showDirtyState
4	11	----> if not set -q dirty[1]
        set -q __fish_git_prompt_showdirtystate
        and set dirty true
    ...
4	4	-----> not set -q dirty[1]
3	3	-----> set -q __fish_git_prompt_showdirtystate
38	523	----> set -l untracked (command git config --bool bash.showUntrackedFiles)
485	485	-----> command git config --bool bash.showUntrackedFiles
3	11	----> if not set -q untracked[1]
        set -q __fish_git_prompt_showuntrackedfiles
        and set untracked true
    ...
4	4	-----> not set -q untracked[1]
4	4	-----> set -q __fish_git_prompt_showuntrackedfiles
4	51	----> if test "true" = $inside_worktree
        # Use informative status if it has been enabled locally, or it has been
        # enabled globally (via the fish variable) and dirty or untracked are not false.
        #
        # This is to allow overrides for the repository.
        if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        end

        if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        end
    ...
7	7	-----> test "true" = $inside_worktree
7	32	-----> if test "$informative" = true
            or begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            end
            set informative_status "$space"(__fish_git_prompt_informative_status $git_dir)
        else
            # This has to be set explicitly.
            if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            end

            if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            end

            if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            end
        ...
4	4	------> test "$informative" = true
2	6	------> begin
                set -q __fish_git_prompt_show_informative_status
                and test "$dirty" != false
                and test "$untracked" != false
            ...
4	4	-------> set -q __fish_git_prompt_show_informative_status
1	5	------> if test "$dirty" = true
                set w (__fish_git_prompt_dirty)
                set i (__fish_git_prompt_staged $sha)
            ...
4	4	-------> test "$dirty" = true
2	5	------> if set -q __fish_git_prompt_showstashstate
                and test -r $git_dir/refs/stash
                set s $___fish_git_prompt_char_stashstate
            ...
3	3	-------> set -q __fish_git_prompt_showstashstate
1	5	------> if test "$untracked" = true
                set u (__fish_git_prompt_untracked)
            ...
4	4	-------> test "$untracked" = true
2	8	-----> if set -q __fish_git_prompt_showupstream
            or set -q __fish_git_prompt_show_informative_status
            set p (__fish_git_prompt_show_upstream)
        ...
3	3	------> set -q __fish_git_prompt_showupstream
3	3	------> set -q __fish_git_prompt_show_informative_status
7	7	----> set -l branch_color $___fish_git_prompt_color_branch
6	6	----> set -l branch_done $___fish_git_prompt_color_branch_done
1	4	----> if set -q __fish_git_prompt_showcolorhints
        if test $detached = yes
            set branch_color $___fish_git_prompt_color_branch_detached
            set branch_done $___fish_git_prompt_color_branch_detached_done
        end
    ...
3	3	-----> set -q __fish_git_prompt_showcolorhints
2	6	----> if test -n "$w"
        set w "$___fish_git_prompt_color_dirtystate$w$___fish_git_prompt_color_dirtystate_done"
    ...
4	4	-----> test -n "$w"
1	5	----> if test -n "$i"
        set i "$___fish_git_prompt_color_stagedstate$i$___fish_git_prompt_color_stagedstate_done"
    ...
4	4	-----> test -n "$i"
1	5	----> if test -n "$s"
        set s "$___fish_git_prompt_color_stashstate$s$___fish_git_prompt_color_stashstate_done"
    ...
4	4	-----> test -n "$s"
0	4	----> if test -n "$u"
        set u "$___fish_git_prompt_color_untrackedfiles$u$___fish_git_prompt_color_untrackedfiles_done"
    ...
4	4	-----> test -n "$u"
41	54	----> set b (string replace refs/heads/ '' -- $b)
13	13	-----> string replace refs/heads/ '' -- $b
4	4	----> set -q __fish_git_prompt_shorten_branch_char_suffix
6	6	----> set -l __fish_git_prompt_shorten_branch_char_suffix "…"
1	17	----> if string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"; and test (string length "$b") -gt $__fish_git_prompt_shorten_branch_len
        set b (string sub -l "$__fish_git_prompt_shorten_branch_len" "$b")"$__fish_git_prompt_shorten_branch_char_suffix"
    ...
16	16	-----> string match -qr '^\d+$' "$__fish_git_prompt_shorten_branch_len"
2	14	----> if test -n "$b"
        set b "$branch_color$b$branch_done"
    ...
5	5	-----> test -n "$b"
7	7	-----> set b "$branch_color$b$branch_done"
1	5	----> if test -n "$c"
        set c "$___fish_git_prompt_color_bare$c$___fish_git_prompt_color_bare_done"
    ...
4	4	-----> test -n "$c"
1	5	----> if test -n "$r"
        set r "$___fish_git_prompt_color_merging$r$___fish_git_prompt_color_merging_done"
    ...
4	4	-----> test -n "$r"
0	4	----> if test -n "$p"
        set p "$___fish_git_prompt_color_upstream$p$___fish_git_prompt_color_upstream_done"
    ...
4	4	-----> test -n "$p"
9	9	----> set -l f "$w$i$s$u"
2	5	----> if test -n "$f"
        set f "$space$f"
    ...
3	3	-----> test -n "$f"
6	6	----> set -l format $argv[1]
2	11	----> if test -z "$format"
        set format " (%s)"
    ...
4	4	-----> test -z "$format"
5	5	-----> set format " (%s)"
19	19	----> printf "%s$format%s" "$___fish_git_prompt_color_prefix" "$___fish_git_prompt_color_prefix_done$c$b$f$r$p$informative_status$___fish_git_prompt_color_suffix" "$___fish_git_prompt_color_suffix_done"
9	107	> fish_title
4	98	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
4	4	--> not set -q INSIDE_EMACS
68	90	--> echo (status current-command) (__fish_pwd)
6	6	---> status current-command
10	16	---> __fish_pwd
6	6	----> pwd
37	290	> fish_vi_cursor_handle_preexec exit
20	20	-> set -l varname fish_cursor_default
1	17	-> if not set -q $varname
                set varname fish_cursor_unknown
              ...
16	16	--> not set -q $varname
32	216	-> __fish_cursor_xterm $$varname
15	15	--> set -l shape $argv[1]
10	19	--> switch "$shape"
        case block
            set shape 2
        case underscore
            set shape 4
        case line
            set shape 6
    ...
9	9	---> set shape 2
6	132	--> if contains blink $argv
        set shape (math $shape - 1)
    ...
14	14	---> contains blink $argv
77	112	---> set shape (math $shape - 1)
35	35	----> math $shape - 1
18	18	--> echo -en "\e[$shape q"
16	31	> __fish_disable_bracketed_paste exit
15	15	-> printf "\e[?2004l"
16	228	> fish_title exit
6	212	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
9	9	--> not set -q INSIDE_EMACS
146	197	--> echo (status current-command) (__fish_pwd)
12	12	---> status current-command
22	39	---> __fish_pwd
17	17	----> pwd
31	31	> exit
14	30	> __fish_disable_bracketed_paste 0
16	16	-> printf "\e[?2004l"
